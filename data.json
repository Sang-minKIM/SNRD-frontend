{
  "mainpage": [
    {
      "PM": [
        {
          "id": 3,
          "categoryIndex": 3,
          "part": "plan",
          "topic": "솔루션",
          "contents": "이게 왜 바로 안넘어 갈까?\n**이걸 어떻게 비동기 처리하지.........**\n이제 또 넘어가기 시작하네",
          "commentCounts": 0
        },
        {
          "id": 2,
          "categoryIndex": 2,
          "part": "plan",
          "topic": "시장조사/자료조사",
          "contents": "> *Use a central mediator object to handle communication between components*\n\n## Mediator\n\n- 애플리케이션은 독립된 object들로 만들어진다. \nobject간의 통신은 유지보수가 쉽고 다른 object를 건드리지 않으면서, 애플리케이션의 일부분을 안전하게 수정할 수 있는 방식으로 이루어져야한다.\n    ![](https://velog.velcdn.com/images/sang-mini/post/4d7e63eb-a41d-4211-8238-ddd0c042170c/image.png)\n\n\n    \n\n- 애플리케이션의 크기가 커져가면서 더욱 더 많은 object들이 추가, 제거, 재배치된다. 이때 object들이 서로에 대해 너무 많은 정보를 아는 상태로 직접 통신하게 되면 서로간의 결합도가 높아져 바람직하지 않다. **object들이 강하게 결합되면, 다른 object들에 영향을 주지 않고 하나의 object를 수정하기가 어렵다.** \n\n- 우리는 object 간의 다방향 데이터를 처리해야 한다. 하지만 component가 많으면 component 간의 통신이 다소 혼란스러울 수 있다.\n- 이러한 이유로 component들이 서로 직접 통신하는 대신 mediator를 통하도록 한다. \n(mediator가 관제탑, component가 비행기라고 생각하면 된다.)\n\n\n>  _ component vs object\n 컴포넌트가 사람이 눈으로 확인할 수 있는 결과물이라면 객체는 사람이 눈으로 확인할 수 없는 작은 단위의 사물과 같다. 객체도 독립적으로 작동할 수 있지만 보통 다른 객체와 관계를 맺어 결과물을 제출한다. 다른 객체와 관계를 맺어 하나의 모듈이 되었으면 이 모듈이 곧 컴포넌트가 되기도 한다. 객체는 컴포넌트보다는 작은 단위의 기능을 수행한다. 컴포넌트는 독립적으로 작동하는 큰 단위의 모듈이다. 객체가 모여 컴포넌트가 된다. 컴포넌트는 사람이 직접적, 물질적으로 인식할 수 있는 대상이다._\n\n\n\n\n- **Mediator pattern**에서는 독립된 object들은 다른 object와 직접 통신하지 않고, **Mediator**를 거친다. \nJS에서 Mediator는 보통 object literal이나 function으로 구현된다. \n![](https://velog.velcdn.com/images/sang-mini/post/cfcaeff3-4401-4f25-adfc-6bdfdb44a4be/image.png)\n\n - ### 활용 \n 채팅방 기능\n```javascript\nclass ChatRoom {\n  logMessage(user, message) {\n    const time = new Date();\n    const sender = user.getName();\n\n    console.log(`${time} [${sender}]: ${message}`);\n  }\n}\n\n class User {\n  constructor(name, chatroom) {\n    this.name = name;\n    this.chatroom = chatroom;\n  }\n\n  getName() {\n    return this.name;\n  }\n\n  send(message) {\n    this.chatroom.logMessage(this, message);\n  }\n}\n```\n\n  [CodeSandBox](https://codesandbox.io/s/middleware-1-forked-jxts4w?file=/src/index.js)\n\n## Middleware\n\n- **Middleware** = middle software\nmiddleware는 **request와 respond 사이**에 있는 contoller다.\n- express가 middleware라는 용어를 대중화하여 구체적으로 디자인 패턴을 구현했다. 이를 통해 개발자가 프레임워크의 핵심에 손대지 않고도 새로운 기능을 쉽게 만들고 배포하여 기능을 추가할 수 있도록 했다.\n- 구조\n![](https://velog.velcdn.com/images/sang-mini/post/e0a0ce03-d617-4f04-8602-5110aff64d88/image.png)\n\n - middleware에 처리를 위한 새로운 데이터가 수신되면 등록된 middleware 들이 비동기 순차 실행 흐름으로 호출된다. next 함수가 req - res 사이클에 걸려있는 다음 callback을 호출한다.\n-각 middleware는 데이터의 추가적인 처리를 중단시킬 수 있다. callback을 호출하지 않거나 오류를 전파하여 동작한다. \n\n- 새로운 middleware는 use()함수를 통해 등록할 수 있다. \n```jsx\n    const app = require('express')()\n    \n    app.use('/', (req, res, next) => {\n      req.headers['test-header'] = 1234\n      next()\n    })\n```\n\n\n### 활용\n이 미들웨어 패턴은 여러 객체 간 다대 다의 통신을 하나의 관리 포인트를 통하도록 만들어 관계를 단순하게 만들어준다.\n```jsx\n    import express from \"express\";\n    \n    const app = express();\n    \n    const urlLogger = (req, res, next) => {\n      console.log(`Path: ${req.path}`);\n      next();\n    };\n    \n    const timeLogger = (req, res, next) => {\n      const today = new Date();\n      const year = today.getFullYear();\n      const month = today.getMonth() + 1;\n      const day = today.getDate();\n      const date = `${year}.${month}.${day}`;\n      console.log(`Time: ${date}`);\n      next();\n    };\n    \n    const securityLogger = (req, res, next) => {\n      req.protocol === \"https\" ? console.log(\"Secure\") : console.log(\"Insecure\");\n      next();\n    };\n    \n    const protector = (req, res) => {\n      res.end();\n    };\n    \n    app.use(urlLogger, timeLogger, securityLogger);\n    app.get(\"/\", (req, res) => res.send(\"<h1>Home</h1>\"));\n    app.get(\"/protected\", protector, (req, res) => res.send(\"<h1>Protected</h1>\"));\n    \n    app.listen(process.env.PORT, () => `Listening!✅`);\n```\n [ CodeSandBox](https://codesandbox.io/s/a03blueprint-forked-89y5yu?file=/src/server.js)\n\n## 장단점\n- 장점\n  - object들 간 수정을 하지 않고 관계를 수정할 수 있다.\n  - object들 간의 관계의 복잡도, 의존성 및 결합도를 감소시킨다.\n다대 다의 복잡한 의존 관계를 풀어나감\n- 단점\n  - 중재자에 권한이 집중되어 있으므로 잘못된 중재자의 설계는 더 복잡한 객체를 생성할 수 있다. \n\n## 참고\n\n[Mediator/Middleware Pattern](https://www.patterns.dev/posts/mediator-pattern/)\n\n- JavaScript patterns - Stoyan Stefaonv\n- Node.js 디자인 패턴 바이블 - Mario Casciaro, Luciano Mammino\n",
          "commentCounts": 0
        },
        {
          "id": 3,
          "categoryIndex": 3,
          "part": "plan",
          "topic": "솔루션",
          "contents": "이게 왜 바로 안넘어 갈까?\n**이걸 어떻게 비동기 처리하지.........**\n이제 또 넘어가기 시작하네",
          "commentCounts": 0
        },
        {
          "id": 4,
          "categoryIndex": 4,
          "part": "plan",
          "topic": "목표가 아닌 것",
          "contents": "처음 올릴때만 안되는 건가?\n이제 될듯",
          "commentCounts": 4
        },
        {
          "id": 5,
          "categoryIndex": 5,
          "part": "plan",
          "topic": "벤치마크",
          "contents": "> *Use a central mediator object to handle communication between components*\n\n## Mediator\n\n- 애플리케이션은 독립된 object들로 만들어진다. \nobject간의 통신은 유지보수가 쉽고 다른 object를 건드리지 않으면서, 애플리케이션의 일부분을 안전하게 수정할 수 있는 방식으로 이루어져야한다.\n    ![](https://velog.velcdn.com/images/sang-mini/post/4d7e63eb-a41d-4211-8238-ddd0c042170c/image.png)\n\n\n    \n\n- 애플리케이션의 크기가 커져가면서 더욱 더 많은 object들이 추가, 제거, 재배치된다. 이때 object들이 서로에 대해 너무 많은 정보를 아는 상태로 직접 통신하게 되면 서로간의 결합도가 높아져 바람직하지 않다. **object들이 강하게 결합되면, 다른 object들에 영향을 주지 않고 하나의 object를 수정하기가 어렵다.** \n\n- 우리는 object 간의 다방향 데이터를 처리해야 한다. 하지만 component가 많으면 component 간의 통신이 다소 혼란스러울 수 있다.\n- 이러한 이유로 component들이 서로 직접 통신하는 대신 mediator를 통하도록 한다. \n(mediator가 관제탑, component가 비행기라고 생각하면 된다.)\n\n\n>  _ component vs object\n 컴포넌트가 사람이 눈으로 확인할 수 있는 결과물이라면 객체는 사람이 눈으로 확인할 수 없는 작은 단위의 사물과 같다. 객체도 독립적으로 작동할 수 있지만 보통 다른 객체와 관계를 맺어 결과물을 제출한다. 다른 객체와 관계를 맺어 하나의 모듈이 되었으면 이 모듈이 곧 컴포넌트가 되기도 한다. 객체는 컴포넌트보다는 작은 단위의 기능을 수행한다. 컴포넌트는 독립적으로 작동하는 큰 단위의 모듈이다. 객체가 모여 컴포넌트가 된다. 컴포넌트는 사람이 직접적, 물질적으로 인식할 수 있는 대상이다._\n\n\n\n\n- **Mediator pattern**에서는 독립된 object들은 다른 object와 직접 통신하지 않고, **Mediator**를 거친다. \nJS에서 Mediator는 보통 object literal이나 function으로 구현된다. \n![](https://velog.velcdn.com/images/sang-mini/post/cfcaeff3-4401-4f25-adfc-6bdfdb44a4be/image.png)\n\n - ### 활용 \n 채팅방 기능\n```javascript\nclass ChatRoom {\n  logMessage(user, message) {\n    const time = new Date();\n    const sender = user.getName();\n\n    console.log(`${time} [${sender}]: ${message}`);\n  }\n}\n\n class User {\n  constructor(name, chatroom) {\n    this.name = name;\n    this.chatroom = chatroom;\n  }\n\n  getName() {\n    return this.name;\n  }\n\n  send(message) {\n    this.chatroom.logMessage(this, message);\n  }\n}\n```\n\n  [CodeSandBox](https://codesandbox.io/s/middleware-1-forked-jxts4w?file=/src/index.js)\n\n## Middleware\n\n- **Middleware** = middle software\nmiddleware는 **request와 respond 사이**에 있는 contoller다.\n- express가 middleware라는 용어를 대중화하여 구체적으로 디자인 패턴을 구현했다. 이를 통해 개발자가 프레임워크의 핵심에 손대지 않고도 새로운 기능을 쉽게 만들고 배포하여 기능을 추가할 수 있도록 했다.\n- 구조\n![](https://velog.velcdn.com/images/sang-mini/post/e0a0ce03-d617-4f04-8602-5110aff64d88/image.png)\n\n - middleware에 처리를 위한 새로운 데이터가 수신되면 등록된 middleware 들이 비동기 순차 실행 흐름으로 호출된다. next 함수가 req - res 사이클에 걸려있는 다음 callback을 호출한다.\n-각 middleware는 데이터의 추가적인 처리를 중단시킬 수 있다. callback을 호출하지 않거나 오류를 전파하여 동작한다. \n\n- 새로운 middleware는 use()함수를 통해 등록할 수 있다. \n```jsx\n    const app = require('express')()\n    \n    app.use('/', (req, res, next) => {\n      req.headers['test-header'] = 1234\n      next()\n    })\n```\n\n\n### 활용\n이 미들웨어 패턴은 여러 객체 간 다대 다의 통신을 하나의 관리 포인트를 통하도록 만들어 관계를 단순하게 만들어준다.\n```jsx\n    import express from \"express\";\n    \n    const app = express();\n    \n    const urlLogger = (req, res, next) => {\n      console.log(`Path: ${req.path}`);\n      next();\n    };\n    \n    const timeLogger = (req, res, next) => {\n      const today = new Date();\n      const year = today.getFullYear();\n      const month = today.getMonth() + 1;\n      const day = today.getDate();\n      const date = `${year}.${month}.${day}`;\n      console.log(`Time: ${date}`);\n      next();\n    };\n    \n    const securityLogger = (req, res, next) => {\n      req.protocol === \"https\" ? console.log(\"Secure\") : console.log(\"Insecure\");\n      next();\n    };\n    \n    const protector = (req, res) => {\n      res.end();\n    };\n    \n    app.use(urlLogger, timeLogger, securityLogger);\n    app.get(\"/\", (req, res) => res.send(\"<h1>Home</h1>\"));\n    app.get(\"/protected\", protector, (req, res) => res.send(\"<h1>Protected</h1>\"));\n    \n    app.listen(process.env.PORT, () => `Listening!✅`);\n```\n [ CodeSandBox](https://codesandbox.io/s/a03blueprint-forked-89y5yu?file=/src/server.js)\n\n## 장단점\n- 장점\n  - object들 간 수정을 하지 않고 관계를 수정할 수 있다.\n  - object들 간의 관계의 복잡도, 의존성 및 결합도를 감소시킨다.\n다대 다의 복잡한 의존 관계를 풀어나감\n- 단점\n  - 중재자에 권한이 집중되어 있으므로 잘못된 중재자의 설계는 더 복잡한 객체를 생성할 수 있다. \n\n## 참고\n\n[Mediator/Middleware Pattern](https://www.patterns.dev/posts/mediator-pattern/)\n\n- JavaScript patterns - Stoyan Stefaonv\n- Node.js 디자인 패턴 바이블 - Mario Casciaro, Luciano Mammino\n",
          "commentCounts": 0
        },
        {
          "id": 0,
          "categoryIndex": 0,
          "part": "plan",
          "topic": "배경/문제인식",
          "contents": "> *Use a central mediator object to handle communication between components*\n\n## Mediator\n\n- 애플리케이션은 독립된 object들로 만들어진다. \nobject간의 통신은 유지보수가 쉽고 다른 object를 건드리지 않으면서, 애플리케이션의 일부분을 안전하게 수정할 수 있는 방식으로 이루어져야한다.\n    ![](https://velog.velcdn.com/images/sang-mini/post/4d7e63eb-a41d-4211-8238-ddd0c042170c/image.png)\n\n\n    \n\n- 애플리케이션의 크기가 커져가면서 더욱 더 많은 object들이 추가, 제거, 재배치된다. 이때 object들이 서로에 대해 너무 많은 정보를 아는 상태로 직접 통신하게 되면 서로간의 결합도가 높아져 바람직하지 않다. **object들이 강하게 결합되면, 다른 object들에 영향을 주지 않고 하나의 object를 수정하기가 어렵다.** \n\n- 우리는 object 간의 다방향 데이터를 처리해야 한다. 하지만 component가 많으면 component 간의 통신이 다소 혼란스러울 수 있다.\n- 이러한 이유로 component들이 서로 직접 통신하는 대신 mediator를 통하도록 한다. \n(mediator가 관제탑, component가 비행기라고 생각하면 된다.)\n\n\n>  _ component vs object\n 컴포넌트가 사람이 눈으로 확인할 수 있는 결과물이라면 객체는 사람이 눈으로 확인할 수 없는 작은 단위의 사물과 같다. 객체도 독립적으로 작동할 수 있지만 보통 다른 객체와 관계를 맺어 결과물을 제출한다. 다른 객체와 관계를 맺어 하나의 모듈이 되었으면 이 모듈이 곧 컴포넌트가 되기도 한다. 객체는 컴포넌트보다는 작은 단위의 기능을 수행한다. 컴포넌트는 독립적으로 작동하는 큰 단위의 모듈이다. 객체가 모여 컴포넌트가 된다. 컴포넌트는 사람이 직접적, 물질적으로 인식할 수 있는 대상이다._\n\n\n\n\n- **Mediator pattern**에서는 독립된 object들은 다른 object와 직접 통신하지 않고, **Mediator**를 거친다. \nJS에서 Mediator는 보통 object literal이나 function으로 구현된다. \n![](https://velog.velcdn.com/images/sang-mini/post/cfcaeff3-4401-4f25-adfc-6bdfdb44a4be/image.png)\n\n - ### 활용 \n 채팅방 기능\n```javascript\nclass ChatRoom {\n  logMessage(user, message) {\n    const time = new Date();\n    const sender = user.getName();\n\n    console.log(`${time} [${sender}]: ${message}`);\n  }\n}\n\n class User {\n  constructor(name, chatroom) {\n    this.name = name;\n    this.chatroom = chatroom;\n  }\n\n  getName() {\n    return this.name;\n  }\n\n  send(message) {\n    this.chatroom.logMessage(this, message);\n  }\n}\n```\n\n  [CodeSandBox](https://codesandbox.io/s/middleware-1-forked-jxts4w?file=/src/index.js)\n\n## Middleware\n\n- **Middleware** = middle software\nmiddleware는 **request와 respond 사이**에 있는 contoller다.\n- express가 middleware라는 용어를 대중화하여 구체적으로 디자인 패턴을 구현했다. 이를 통해 개발자가 프레임워크의 핵심에 손대지 않고도 새로운 기능을 쉽게 만들고 배포하여 기능을 추가할 수 있도록 했다.\n- 구조\n![](https://velog.velcdn.com/images/sang-mini/post/e0a0ce03-d617-4f04-8602-5110aff64d88/image.png)\n\n - middleware에 처리를 위한 새로운 데이터가 수신되면 등록된 middleware 들이 비동기 순차 실행 흐름으로 호출된다. next 함수가 req - res 사이클에 걸려있는 다음 callback을 호출한다.\n-각 middleware는 데이터의 추가적인 처리를 중단시킬 수 있다. callback을 호출하지 않거나 오류를 전파하여 동작한다. \n\n- 새로운 middleware는 use()함수를 통해 등록할 수 있다. \n```jsx\n    const app = require('express')()\n    \n    app.use('/', (req, res, next) => {\n      req.headers['test-header'] = 1234\n      next()\n    })\n```\n\n\n### 활용\n이 미들웨어 패턴은 여러 객체 간 다대 다의 통신을 하나의 관리 포인트를 통하도록 만들어 관계를 단순하게 만들어준다.\n```jsx\n    import express from \"express\";\n    \n    const app = express();\n    \n    const urlLogger = (req, res, next) => {\n      console.log(`Path: ${req.path}`);\n      next();\n    };\n    \n    const timeLogger = (req, res, next) => {\n      const today = new Date();\n      const year = today.getFullYear();\n      const month = today.getMonth() + 1;\n      const day = today.getDate();\n      const date = `${year}.${month}.${day}`;\n      console.log(`Time: ${date}`);\n      next();\n    };\n    \n    const securityLogger = (req, res, next) => {\n      req.protocol === \"https\" ? console.log(\"Secure\") : console.log(\"Insecure\");\n      next();\n    };\n    \n    const protector = (req, res) => {\n      res.end();\n    };\n    \n    app.use(urlLogger, timeLogger, securityLogger);\n    app.get(\"/\", (req, res) => res.send(\"<h1>Home</h1>\"));\n    app.get(\"/protected\", protector, (req, res) => res.send(\"<h1>Protected</h1>\"));\n    \n    app.listen(process.env.PORT, () => `Listening!✅`);\n```\n [ CodeSandBox](https://codesandbox.io/s/a03blueprint-forked-89y5yu?file=/src/server.js)\n\n## 장단점\n- 장점\n  - object들 간 수정을 하지 않고 관계를 수정할 수 있다.\n  - object들 간의 관계의 복잡도, 의존성 및 결합도를 감소시킨다.\n다대 다의 복잡한 의존 관계를 풀어나감\n- 단점\n  - 중재자에 권한이 집중되어 있으므로 잘못된 중재자의 설계는 더 복잡한 객체를 생성할 수 있다. \n\n## 참고\n\n[Mediator/Middleware Pattern](https://www.patterns.dev/posts/mediator-pattern/)\n\n- JavaScript patterns - Stoyan Stefaonv\n- Node.js 디자인 패턴 바이블 - Mario Casciaro, Luciano Mammino\n",
          "commentCounts": 0
        },
        {
          "id": 1,
          "categoryIndex": 1,
          "part": "plan",
          "topic": "타겟설정",
          "contents": "## 도입\n\n\n**React Query**는 통신, 캐싱, 에러처리 등에서의 많은 장점을 가지고 있다. 나는 데이터 통신 위주로 가볍게 사용해보고 정리하려 한다. loading을 useState로 만들고, useEffect로 데이터를 받아온 후 state를 바꿔주는 과정을 간단하게 대체하고 재활용 가능한 코드로 만들어준다는 것만으로도 매력적이었다. \n\n## Setting\n\n```jsx\nnpm i @tanstack/react-query\n```\n\n1. queryClient 만들기\n    \n    ```tsx\n    //index.tsx\n    import { QueryClient, QueryClientProvider } from \"@tanstack/react-query\";\n    \n    const queryClient = new QueryClient();\n    ```\n    \n2. application을 QueryClientProvider로 감싸기\n    \n    ```tsx\n    //index.tsx\n    <QueryClientProvider client={queryClient}>   \n    \t\t<App />    \n    </QueryClientProvider>\n    ```\n    \n3. fetcher 만들기\nreact query는 fetcher함수를 만들 수 있게 해준다.  기본적으로 fetcher function과 연결시켜서 isLoading 같은 함수가 불렸는지 아닌지를 알려준다. 함수가 끝났을 때는 결과 값을 data에 주고 그 data에 아주 쉬운 방법으로 접근할 수 있게 도와준다. \n    \n   ```tsx\n    \t//api.ts\n    export function getTasks() {\n    return fetch(`${BASE_URL}/task`).then((response) => response.json());\n\t\t}\n   ```\n   _다른 컴포넌트에서 import해서 사용할 수 있도록 export 해준다._\n\n## 사용하기\n- useQuery는 isLoading, data, error, isError등 많은 것에 접근할 수 있다. key와 fetcher 함수를 넣어주면 바로 사용할 수 있다. 이때 key는 array로 줄 것. (version 4 로 오면서 바뀜)\n    \n    ```jsx\n    const { isLoading, data } = useQuery([\"tasks\"], getTasks);\n    ```\n    \n    이때, 필요하다면(typescript) data의 타입을 알려준다.\n    \n    ```tsx\n\tinterface IContents {\n  \t\tid: number;\n  \t\tcategoryIndex: number;\n        \tpart: string;\n  \t\ttopic: string;\n  \t\tcontents: any;\n  \t\tcommentCounts: number;\n\t\t}\n\n     \t\t const { isLoading: contentLoading, data: contentData } = useQuery<IContents>(\n    \t\t\t[\"content\", contentId],\n   \t \t\t() => getContents(contentId)\n  \t\t);\n    ```\nreact query는 아주 강력한 캐싱 매커니즘을 가지고 있다. 만약 query의 고유한 key값을 react query에 넘겨 주었다면 react query는 캐시에 이미 data가 있는 것을 알고 loading을 보여주지 않고 페이지를 넘겨준다. \n    또, 같은 쿼리를 다른 화면이나 다른 컴포넌트에서 사용했다면 fetch가 다시 일어나지 않을 것이다.\n    \n\n - argument를 필요로 하는 fetcher function의 경우에는 익명의 함수를 만들어서 fetcher function를 return해준다.\n  ```tsx\ngetTasks\n() => getTasks()\n//두 표현이 동일한 의미이다. \n  ```\n  _ getTasks(id)로 적을경우 함수가 바로 실행되기 때문에 적절하지 못하다. _\n  \n\n ",
          "commentCounts": 1
        },
        {
          "id": 1671099903684,
          "categoryIndex": 6,
          "part": "plan",
          "topic": "수나롭다",
          "contents": "",
          "commentCounts": 0
        }
      ],
      "Design": [
        {
          "id": 6,
          "categoryIndex": 0,
          "part": "design",
          "topic": "Mood board",
          "contents": "> *Use a central mediator object to handle communication between components*\n\n## Mediator\n\n- 애플리케이션은 독립된 object들로 만들어진다. \nobject간의 통신은 유지보수가 쉽고 다른 object를 건드리지 않으면서, 애플리케이션의 일부분을 안전하게 수정할 수 있는 방식으로 이루어져야한다.\n    ![](https://velog.velcdn.com/images/sang-mini/post/4d7e63eb-a41d-4211-8238-ddd0c042170c/image.png)\n\n\n    \n\n- 애플리케이션의 크기가 커져가면서 더욱 더 많은 object들이 추가, 제거, 재배치된다. 이때 object들이 서로에 대해 너무 많은 정보를 아는 상태로 직접 통신하게 되면 서로간의 결합도가 높아져 바람직하지 않다. **object들이 강하게 결합되면, 다른 object들에 영향을 주지 않고 하나의 object를 수정하기가 어렵다.** \n\n- 우리는 object 간의 다방향 데이터를 처리해야 한다. 하지만 component가 많으면 component 간의 통신이 다소 혼란스러울 수 있다.\n- 이러한 이유로 component들이 서로 직접 통신하는 대신 mediator를 통하도록 한다. \n(mediator가 관제탑, component가 비행기라고 생각하면 된다.)\n\n\n>  _ component vs object\n 컴포넌트가 사람이 눈으로 확인할 수 있는 결과물이라면 객체는 사람이 눈으로 확인할 수 없는 작은 단위의 사물과 같다. 객체도 독립적으로 작동할 수 있지만 보통 다른 객체와 관계를 맺어 결과물을 제출한다. 다른 객체와 관계를 맺어 하나의 모듈이 되었으면 이 모듈이 곧 컴포넌트가 되기도 한다. 객체는 컴포넌트보다는 작은 단위의 기능을 수행한다. 컴포넌트는 독립적으로 작동하는 큰 단위의 모듈이다. 객체가 모여 컴포넌트가 된다. 컴포넌트는 사람이 직접적, 물질적으로 인식할 수 있는 대상이다._\n\n\n\n\n- **Mediator pattern**에서는 독립된 object들은 다른 object와 직접 통신하지 않고, **Mediator**를 거친다. \nJS에서 Mediator는 보통 object literal이나 function으로 구현된다. \n![](https://velog.velcdn.com/images/sang-mini/post/cfcaeff3-4401-4f25-adfc-6bdfdb44a4be/image.png)\n\n - ### 활용 \n 채팅방 기능\n```javascript\nclass ChatRoom {\n  logMessage(user, message) {\n    const time = new Date();\n    const sender = user.getName();\n\n    console.log(`${time} [${sender}]: ${message}`);\n  }\n}\n\n class User {\n  constructor(name, chatroom) {\n    this.name = name;\n    this.chatroom = chatroom;\n  }\n\n  getName() {\n    return this.name;\n  }\n\n  send(message) {\n    this.chatroom.logMessage(this, message);\n  }\n}\n```\n\n  [CodeSandBox](https://codesandbox.io/s/middleware-1-forked-jxts4w?file=/src/index.js)\n\n## Middleware\n\n- **Middleware** = middle software\nmiddleware는 **request와 respond 사이**에 있는 contoller다.\n- express가 middleware라는 용어를 대중화하여 구체적으로 디자인 패턴을 구현했다. 이를 통해 개발자가 프레임워크의 핵심에 손대지 않고도 새로운 기능을 쉽게 만들고 배포하여 기능을 추가할 수 있도록 했다.\n- 구조\n![](https://velog.velcdn.com/images/sang-mini/post/e0a0ce03-d617-4f04-8602-5110aff64d88/image.png)\n\n - middleware에 처리를 위한 새로운 데이터가 수신되면 등록된 middleware 들이 비동기 순차 실행 흐름으로 호출된다. next 함수가 req - res 사이클에 걸려있는 다음 callback을 호출한다.\n-각 middleware는 데이터의 추가적인 처리를 중단시킬 수 있다. callback을 호출하지 않거나 오류를 전파하여 동작한다. \n\n- 새로운 middleware는 use()함수를 통해 등록할 수 있다. \n```jsx\n    const app = require('express')()\n    \n    app.use('/', (req, res, next) => {\n      req.headers['test-header'] = 1234\n      next()\n    })\n```\n\n\n### 활용\n이 미들웨어 패턴은 여러 객체 간 다대 다의 통신을 하나의 관리 포인트를 통하도록 만들어 관계를 단순하게 만들어준다.\n```jsx\n    import express from \"express\";\n    \n    const app = express();\n    \n    const urlLogger = (req, res, next) => {\n      console.log(`Path: ${req.path}`);\n      next();\n    };\n    \n    const timeLogger = (req, res, next) => {\n      const today = new Date();\n      const year = today.getFullYear();\n      const month = today.getMonth() + 1;\n      const day = today.getDate();\n      const date = `${year}.${month}.${day}`;\n      console.log(`Time: ${date}`);\n      next();\n    };\n    \n    const securityLogger = (req, res, next) => {\n      req.protocol === \"https\" ? console.log(\"Secure\") : console.log(\"Insecure\");\n      next();\n    };\n    \n    const protector = (req, res) => {\n      res.end();\n    };\n    \n    app.use(urlLogger, timeLogger, securityLogger);\n    app.get(\"/\", (req, res) => res.send(\"<h1>Home</h1>\"));\n    app.get(\"/protected\", protector, (req, res) => res.send(\"<h1>Protected</h1>\"));\n    \n    app.listen(process.env.PORT, () => `Listening!✅`);\n```\n [ CodeSandBox](https://codesandbox.io/s/a03blueprint-forked-89y5yu?file=/src/server.js)\n\n## 장단점\n- 장점\n  - object들 간 수정을 하지 않고 관계를 수정할 수 있다.\n  - object들 간의 관계의 복잡도, 의존성 및 결합도를 감소시킨다.\n다대 다의 복잡한 의존 관계를 풀어나감\n- 단점\n  - 중재자에 권한이 집중되어 있으므로 잘못된 중재자의 설계는 더 복잡한 객체를 생성할 수 있다. \n\n## 참고\n\n[Mediator/Middleware Pattern](https://www.patterns.dev/posts/mediator-pattern/)\n\n- JavaScript patterns - Stoyan Stefaonv\n- Node.js 디자인 패턴 바이블 - Mario Casciaro, Luciano Mammino\n",
          "commentCounts": 0
        },
        {
          "id": 7,
          "categoryIndex": 1,
          "part": "design",
          "topic": "Key color/visual",
          "contents": "> *Use a central mediator object to handle communication between components*\n\n## Mediator\n\n- 애플리케이션은 독립된 object들로 만들어진다. \nobject간의 통신은 유지보수가 쉽고 다른 object를 건드리지 않으면서, 애플리케이션의 일부분을 안전하게 수정할 수 있는 방식으로 이루어져야한다.\n    ![](https://velog.velcdn.com/images/sang-mini/post/4d7e63eb-a41d-4211-8238-ddd0c042170c/image.png)\n\n\n    \n\n- 애플리케이션의 크기가 커져가면서 더욱 더 많은 object들이 추가, 제거, 재배치된다. 이때 object들이 서로에 대해 너무 많은 정보를 아는 상태로 직접 통신하게 되면 서로간의 결합도가 높아져 바람직하지 않다. **object들이 강하게 결합되면, 다른 object들에 영향을 주지 않고 하나의 object를 수정하기가 어렵다.** \n\n- 우리는 object 간의 다방향 데이터를 처리해야 한다. 하지만 component가 많으면 component 간의 통신이 다소 혼란스러울 수 있다.\n- 이러한 이유로 component들이 서로 직접 통신하는 대신 mediator를 통하도록 한다. \n(mediator가 관제탑, component가 비행기라고 생각하면 된다.)\n\n\n>  _ component vs object\n 컴포넌트가 사람이 눈으로 확인할 수 있는 결과물이라면 객체는 사람이 눈으로 확인할 수 없는 작은 단위의 사물과 같다. 객체도 독립적으로 작동할 수 있지만 보통 다른 객체와 관계를 맺어 결과물을 제출한다. 다른 객체와 관계를 맺어 하나의 모듈이 되었으면 이 모듈이 곧 컴포넌트가 되기도 한다. 객체는 컴포넌트보다는 작은 단위의 기능을 수행한다. 컴포넌트는 독립적으로 작동하는 큰 단위의 모듈이다. 객체가 모여 컴포넌트가 된다. 컴포넌트는 사람이 직접적, 물질적으로 인식할 수 있는 대상이다._\n\n\n\n\n- **Mediator pattern**에서는 독립된 object들은 다른 object와 직접 통신하지 않고, **Mediator**를 거친다. \nJS에서 Mediator는 보통 object literal이나 function으로 구현된다. \n![](https://velog.velcdn.com/images/sang-mini/post/cfcaeff3-4401-4f25-adfc-6bdfdb44a4be/image.png)\n\n - ### 활용 \n 채팅방 기능\n```javascript\nclass ChatRoom {\n  logMessage(user, message) {\n    const time = new Date();\n    const sender = user.getName();\n\n    console.log(`${time} [${sender}]: ${message}`);\n  }\n}\n\n class User {\n  constructor(name, chatroom) {\n    this.name = name;\n    this.chatroom = chatroom;\n  }\n\n  getName() {\n    return this.name;\n  }\n\n  send(message) {\n    this.chatroom.logMessage(this, message);\n  }\n}\n```\n\n  [CodeSandBox](https://codesandbox.io/s/middleware-1-forked-jxts4w?file=/src/index.js)\n\n## Middleware\n\n- **Middleware** = middle software\nmiddleware는 **request와 respond 사이**에 있는 contoller다.\n- express가 middleware라는 용어를 대중화하여 구체적으로 디자인 패턴을 구현했다. 이를 통해 개발자가 프레임워크의 핵심에 손대지 않고도 새로운 기능을 쉽게 만들고 배포하여 기능을 추가할 수 있도록 했다.\n- 구조\n![](https://velog.velcdn.com/images/sang-mini/post/e0a0ce03-d617-4f04-8602-5110aff64d88/image.png)\n\n - middleware에 처리를 위한 새로운 데이터가 수신되면 등록된 middleware 들이 비동기 순차 실행 흐름으로 호출된다. next 함수가 req - res 사이클에 걸려있는 다음 callback을 호출한다.\n-각 middleware는 데이터의 추가적인 처리를 중단시킬 수 있다. callback을 호출하지 않거나 오류를 전파하여 동작한다. \n\n- 새로운 middleware는 use()함수를 통해 등록할 수 있다. \n```jsx\n    const app = require('express')()\n    \n    app.use('/', (req, res, next) => {\n      req.headers['test-header'] = 1234\n      next()\n    })\n```\n\n\n### 활용\n이 미들웨어 패턴은 여러 객체 간 다대 다의 통신을 하나의 관리 포인트를 통하도록 만들어 관계를 단순하게 만들어준다.\n```jsx\n    import express from \"express\";\n    \n    const app = express();\n    \n    const urlLogger = (req, res, next) => {\n      console.log(`Path: ${req.path}`);\n      next();\n    };\n    \n    const timeLogger = (req, res, next) => {\n      const today = new Date();\n      const year = today.getFullYear();\n      const month = today.getMonth() + 1;\n      const day = today.getDate();\n      const date = `${year}.${month}.${day}`;\n      console.log(`Time: ${date}`);\n      next();\n    };\n    \n    const securityLogger = (req, res, next) => {\n      req.protocol === \"https\" ? console.log(\"Secure\") : console.log(\"Insecure\");\n      next();\n    };\n    \n    const protector = (req, res) => {\n      res.end();\n    };\n    \n    app.use(urlLogger, timeLogger, securityLogger);\n    app.get(\"/\", (req, res) => res.send(\"<h1>Home</h1>\"));\n    app.get(\"/protected\", protector, (req, res) => res.send(\"<h1>Protected</h1>\"));\n    \n    app.listen(process.env.PORT, () => `Listening!✅`);\n```\n [ CodeSandBox](https://codesandbox.io/s/a03blueprint-forked-89y5yu?file=/src/server.js)\n\n## 장단점\n- 장점\n  - object들 간 수정을 하지 않고 관계를 수정할 수 있다.\n  - object들 간의 관계의 복잡도, 의존성 및 결합도를 감소시킨다.\n다대 다의 복잡한 의존 관계를 풀어나감\n- 단점\n  - 중재자에 권한이 집중되어 있으므로 잘못된 중재자의 설계는 더 복잡한 객체를 생성할 수 있다. \n\n## 참고\n\n[Mediator/Middleware Pattern](https://www.patterns.dev/posts/mediator-pattern/)\n\n- JavaScript patterns - Stoyan Stefaonv\n- Node.js 디자인 패턴 바이블 - Mario Casciaro, Luciano Mammino\n",
          "commentCounts": 0
        },
        {
          "id": 9,
          "categoryIndex": 3,
          "part": "design",
          "topic": "Wireframe",
          "contents": "> *Use a central mediator object to handle communication between components*\n\n## Mediator\n\n- 애플리케이션은 독립된 object들로 만들어진다. \nobject간의 통신은 유지보수가 쉽고 다른 object를 건드리지 않으면서, 애플리케이션의 일부분을 안전하게 수정할 수 있는 방식으로 이루어져야한다.\n    ![](https://velog.velcdn.com/images/sang-mini/post/4d7e63eb-a41d-4211-8238-ddd0c042170c/image.png)\n\n\n    \n\n- 애플리케이션의 크기가 커져가면서 더욱 더 많은 object들이 추가, 제거, 재배치된다. 이때 object들이 서로에 대해 너무 많은 정보를 아는 상태로 직접 통신하게 되면 서로간의 결합도가 높아져 바람직하지 않다. **object들이 강하게 결합되면, 다른 object들에 영향을 주지 않고 하나의 object를 수정하기가 어렵다.** \n\n- 우리는 object 간의 다방향 데이터를 처리해야 한다. 하지만 component가 많으면 component 간의 통신이 다소 혼란스러울 수 있다.\n- 이러한 이유로 component들이 서로 직접 통신하는 대신 mediator를 통하도록 한다. \n(mediator가 관제탑, component가 비행기라고 생각하면 된다.)\n\n\n>  _ component vs object\n 컴포넌트가 사람이 눈으로 확인할 수 있는 결과물이라면 객체는 사람이 눈으로 확인할 수 없는 작은 단위의 사물과 같다. 객체도 독립적으로 작동할 수 있지만 보통 다른 객체와 관계를 맺어 결과물을 제출한다. 다른 객체와 관계를 맺어 하나의 모듈이 되었으면 이 모듈이 곧 컴포넌트가 되기도 한다. 객체는 컴포넌트보다는 작은 단위의 기능을 수행한다. 컴포넌트는 독립적으로 작동하는 큰 단위의 모듈이다. 객체가 모여 컴포넌트가 된다. 컴포넌트는 사람이 직접적, 물질적으로 인식할 수 있는 대상이다._\n\n\n\n\n- **Mediator pattern**에서는 독립된 object들은 다른 object와 직접 통신하지 않고, **Mediator**를 거친다. \nJS에서 Mediator는 보통 object literal이나 function으로 구현된다. \n![](https://velog.velcdn.com/images/sang-mini/post/cfcaeff3-4401-4f25-adfc-6bdfdb44a4be/image.png)\n\n - ### 활용 \n 채팅방 기능\n```javascript\nclass ChatRoom {\n  logMessage(user, message) {\n    const time = new Date();\n    const sender = user.getName();\n\n    console.log(`${time} [${sender}]: ${message}`);\n  }\n}\n\n class User {\n  constructor(name, chatroom) {\n    this.name = name;\n    this.chatroom = chatroom;\n  }\n\n  getName() {\n    return this.name;\n  }\n\n  send(message) {\n    this.chatroom.logMessage(this, message);\n  }\n}\n```\n\n  [CodeSandBox](https://codesandbox.io/s/middleware-1-forked-jxts4w?file=/src/index.js)\n\n## Middleware\n\n- **Middleware** = middle software\nmiddleware는 **request와 respond 사이**에 있는 contoller다.\n- express가 middleware라는 용어를 대중화하여 구체적으로 디자인 패턴을 구현했다. 이를 통해 개발자가 프레임워크의 핵심에 손대지 않고도 새로운 기능을 쉽게 만들고 배포하여 기능을 추가할 수 있도록 했다.\n- 구조\n![](https://velog.velcdn.com/images/sang-mini/post/e0a0ce03-d617-4f04-8602-5110aff64d88/image.png)\n\n - middleware에 처리를 위한 새로운 데이터가 수신되면 등록된 middleware 들이 비동기 순차 실행 흐름으로 호출된다. next 함수가 req - res 사이클에 걸려있는 다음 callback을 호출한다.\n-각 middleware는 데이터의 추가적인 처리를 중단시킬 수 있다. callback을 호출하지 않거나 오류를 전파하여 동작한다. \n\n- 새로운 middleware는 use()함수를 통해 등록할 수 있다. \n```jsx\n    const app = require('express')()\n    \n    app.use('/', (req, res, next) => {\n      req.headers['test-header'] = 1234\n      next()\n    })\n```\n\n\n### 활용\n이 미들웨어 패턴은 여러 객체 간 다대 다의 통신을 하나의 관리 포인트를 통하도록 만들어 관계를 단순하게 만들어준다.\n```jsx\n    import express from \"express\";\n    \n    const app = express();\n    \n    const urlLogger = (req, res, next) => {\n      console.log(`Path: ${req.path}`);\n      next();\n    };\n    \n    const timeLogger = (req, res, next) => {\n      const today = new Date();\n      const year = today.getFullYear();\n      const month = today.getMonth() + 1;\n      const day = today.getDate();\n      const date = `${year}.${month}.${day}`;\n      console.log(`Time: ${date}`);\n      next();\n    };\n    \n    const securityLogger = (req, res, next) => {\n      req.protocol === \"https\" ? console.log(\"Secure\") : console.log(\"Insecure\");\n      next();\n    };\n    \n    const protector = (req, res) => {\n      res.end();\n    };\n    \n    app.use(urlLogger, timeLogger, securityLogger);\n    app.get(\"/\", (req, res) => res.send(\"<h1>Home</h1>\"));\n    app.get(\"/protected\", protector, (req, res) => res.send(\"<h1>Protected</h1>\"));\n    \n    app.listen(process.env.PORT, () => `Listening!✅`);\n```\n [ CodeSandBox](https://codesandbox.io/s/a03blueprint-forked-89y5yu?file=/src/server.js)\n\n## 장단점\n- 장점\n  - object들 간 수정을 하지 않고 관계를 수정할 수 있다.\n  - object들 간의 관계의 복잡도, 의존성 및 결합도를 감소시킨다.\n다대 다의 복잡한 의존 관계를 풀어나감\n- 단점\n  - 중재자에 권한이 집중되어 있으므로 잘못된 중재자의 설계는 더 복잡한 객체를 생성할 수 있다. \n\n## 참고\n\n[Mediator/Middleware Pattern](https://www.patterns.dev/posts/mediator-pattern/)\n\n- JavaScript patterns - Stoyan Stefaonv\n- Node.js 디자인 패턴 바이블 - Mario Casciaro, Luciano Mammino\n",
          "commentCounts": 0
        },
        {
          "id": 8,
          "categoryIndex": 2,
          "part": "design",
          "topic": "UI sketch",
          "contents": "> *Use a central mediator object to handle communication between components*\n\n## Mediator\n\n- 애플리케이션은 독립된 object들로 만들어진다. \nobject간의 통신은 유지보수가 쉽고 다른 object를 건드리지 않으면서, 애플리케이션의 일부분을 안전하게 수정할 수 있는 방식으로 이루어져야한다.\n    ![](https://velog.velcdn.com/images/sang-mini/post/4d7e63eb-a41d-4211-8238-ddd0c042170c/image.png)\n\n\n    \n\n- 애플리케이션의 크기가 커져가면서 더욱 더 많은 object들이 추가, 제거, 재배치된다. 이때 object들이 서로에 대해 너무 많은 정보를 아는 상태로 직접 통신하게 되면 서로간의 결합도가 높아져 바람직하지 않다. **object들이 강하게 결합되면, 다른 object들에 영향을 주지 않고 하나의 object를 수정하기가 어렵다.** \n\n- 우리는 object 간의 다방향 데이터를 처리해야 한다. 하지만 component가 많으면 component 간의 통신이 다소 혼란스러울 수 있다.\n- 이러한 이유로 component들이 서로 직접 통신하는 대신 mediator를 통하도록 한다. \n(mediator가 관제탑, component가 비행기라고 생각하면 된다.)\n\n\n>  _ component vs object\n 컴포넌트가 사람이 눈으로 확인할 수 있는 결과물이라면 객체는 사람이 눈으로 확인할 수 없는 작은 단위의 사물과 같다. 객체도 독립적으로 작동할 수 있지만 보통 다른 객체와 관계를 맺어 결과물을 제출한다. 다른 객체와 관계를 맺어 하나의 모듈이 되었으면 이 모듈이 곧 컴포넌트가 되기도 한다. 객체는 컴포넌트보다는 작은 단위의 기능을 수행한다. 컴포넌트는 독립적으로 작동하는 큰 단위의 모듈이다. 객체가 모여 컴포넌트가 된다. 컴포넌트는 사람이 직접적, 물질적으로 인식할 수 있는 대상이다._\n\n\n\n\n- **Mediator pattern**에서는 독립된 object들은 다른 object와 직접 통신하지 않고, **Mediator**를 거친다. \nJS에서 Mediator는 보통 object literal이나 function으로 구현된다. \n![](https://velog.velcdn.com/images/sang-mini/post/cfcaeff3-4401-4f25-adfc-6bdfdb44a4be/image.png)\n\n - ### 활용 \n 채팅방 기능\n```javascript\nclass ChatRoom {\n  logMessage(user, message) {\n    const time = new Date();\n    const sender = user.getName();\n\n    console.log(`${time} [${sender}]: ${message}`);\n  }\n}\n\n class User {\n  constructor(name, chatroom) {\n    this.name = name;\n    this.chatroom = chatroom;\n  }\n\n  getName() {\n    return this.name;\n  }\n\n  send(message) {\n    this.chatroom.logMessage(this, message);\n  }\n}\n```\n\n  [CodeSandBox](https://codesandbox.io/s/middleware-1-forked-jxts4w?file=/src/index.js)\n\n## Middleware\n\n- **Middleware** = middle software\nmiddleware는 **request와 respond 사이**에 있는 contoller다.\n- express가 middleware라는 용어를 대중화하여 구체적으로 디자인 패턴을 구현했다. 이를 통해 개발자가 프레임워크의 핵심에 손대지 않고도 새로운 기능을 쉽게 만들고 배포하여 기능을 추가할 수 있도록 했다.\n- 구조\n![](https://velog.velcdn.com/images/sang-mini/post/e0a0ce03-d617-4f04-8602-5110aff64d88/image.png)\n\n - middleware에 처리를 위한 새로운 데이터가 수신되면 등록된 middleware 들이 비동기 순차 실행 흐름으로 호출된다. next 함수가 req - res 사이클에 걸려있는 다음 callback을 호출한다.\n-각 middleware는 데이터의 추가적인 처리를 중단시킬 수 있다. callback을 호출하지 않거나 오류를 전파하여 동작한다. \n\n- 새로운 middleware는 use()함수를 통해 등록할 수 있다. \n```jsx\n    const app = require('express')()\n    \n    app.use('/', (req, res, next) => {\n      req.headers['test-header'] = 1234\n      next()\n    })\n```\n\n\n### 활용\n이 미들웨어 패턴은 여러 객체 간 다대 다의 통신을 하나의 관리 포인트를 통하도록 만들어 관계를 단순하게 만들어준다.\n```jsx\n    import express from \"express\";\n    \n    const app = express();\n    \n    const urlLogger = (req, res, next) => {\n      console.log(`Path: ${req.path}`);\n      next();\n    };\n    \n    const timeLogger = (req, res, next) => {\n      const today = new Date();\n      const year = today.getFullYear();\n      const month = today.getMonth() + 1;\n      const day = today.getDate();\n      const date = `${year}.${month}.${day}`;\n      console.log(`Time: ${date}`);\n      next();\n    };\n    \n    const securityLogger = (req, res, next) => {\n      req.protocol === \"https\" ? console.log(\"Secure\") : console.log(\"Insecure\");\n      next();\n    };\n    \n    const protector = (req, res) => {\n      res.end();\n    };\n    \n    app.use(urlLogger, timeLogger, securityLogger);\n    app.get(\"/\", (req, res) => res.send(\"<h1>Home</h1>\"));\n    app.get(\"/protected\", protector, (req, res) => res.send(\"<h1>Protected</h1>\"));\n    \n    app.listen(process.env.PORT, () => `Listening!✅`);\n```\n [ CodeSandBox](https://codesandbox.io/s/a03blueprint-forked-89y5yu?file=/src/server.js)\n\n## 장단점\n- 장점\n  - object들 간 수정을 하지 않고 관계를 수정할 수 있다.\n  - object들 간의 관계의 복잡도, 의존성 및 결합도를 감소시킨다.\n다대 다의 복잡한 의존 관계를 풀어나감\n- 단점\n  - 중재자에 권한이 집중되어 있으므로 잘못된 중재자의 설계는 더 복잡한 객체를 생성할 수 있다. \n\n## 참고\n\n[Mediator/Middleware Pattern](https://www.patterns.dev/posts/mediator-pattern/)\n\n- JavaScript patterns - Stoyan Stefaonv\n- Node.js 디자인 패턴 바이블 - Mario Casciaro, Luciano Mammino\n",
          "commentCounts": 0
        }
      ],
      "Frontend": [
        {
          "id": 10,
          "categoryIndex": 1,
          "part": "frontend",
          "topic": "Setting",
          "contents": "> *Use a central mediator object to handle communication between components*\n\n## Mediator\n\n- 애플리케이션은 독립된 object들로 만들어진다. \nobject간의 통신은 유지보수가 쉽고 다른 object를 건드리지 않으면서, 애플리케이션의 일부분을 안전하게 수정할 수 있는 방식으로 이루어져야한다.\n    ![](https://velog.velcdn.com/images/sang-mini/post/4d7e63eb-a41d-4211-8238-ddd0c042170c/image.png)\n\n\n    \n\n- 애플리케이션의 크기가 커져가면서 더욱 더 많은 object들이 추가, 제거, 재배치된다. 이때 object들이 서로에 대해 너무 많은 정보를 아는 상태로 직접 통신하게 되면 서로간의 결합도가 높아져 바람직하지 않다. **object들이 강하게 결합되면, 다른 object들에 영향을 주지 않고 하나의 object를 수정하기가 어렵다.** \n\n- 우리는 object 간의 다방향 데이터를 처리해야 한다. 하지만 component가 많으면 component 간의 통신이 다소 혼란스러울 수 있다.\n- 이러한 이유로 component들이 서로 직접 통신하는 대신 mediator를 통하도록 한다. \n(mediator가 관제탑, component가 비행기라고 생각하면 된다.)\n\n\n>  _ component vs object\n 컴포넌트가 사람이 눈으로 확인할 수 있는 결과물이라면 객체는 사람이 눈으로 확인할 수 없는 작은 단위의 사물과 같다. 객체도 독립적으로 작동할 수 있지만 보통 다른 객체와 관계를 맺어 결과물을 제출한다. 다른 객체와 관계를 맺어 하나의 모듈이 되었으면 이 모듈이 곧 컴포넌트가 되기도 한다. 객체는 컴포넌트보다는 작은 단위의 기능을 수행한다. 컴포넌트는 독립적으로 작동하는 큰 단위의 모듈이다. 객체가 모여 컴포넌트가 된다. 컴포넌트는 사람이 직접적, 물질적으로 인식할 수 있는 대상이다._\n\n\n\n\n- **Mediator pattern**에서는 독립된 object들은 다른 object와 직접 통신하지 않고, **Mediator**를 거친다. \nJS에서 Mediator는 보통 object literal이나 function으로 구현된다. \n![](https://velog.velcdn.com/images/sang-mini/post/cfcaeff3-4401-4f25-adfc-6bdfdb44a4be/image.png)\n\n - ### 활용 \n 채팅방 기능\n```javascript\nclass ChatRoom {\n  logMessage(user, message) {\n    const time = new Date();\n    const sender = user.getName();\n\n    console.log(`${time} [${sender}]: ${message}`);\n  }\n}\n\n class User {\n  constructor(name, chatroom) {\n    this.name = name;\n    this.chatroom = chatroom;\n  }\n\n  getName() {\n    return this.name;\n  }\n\n  send(message) {\n    this.chatroom.logMessage(this, message);\n  }\n}\n```\n\n  [CodeSandBox](https://codesandbox.io/s/middleware-1-forked-jxts4w?file=/src/index.js)\n\n## Middleware\n\n- **Middleware** = middle software\nmiddleware는 **request와 respond 사이**에 있는 contoller다.\n- express가 middleware라는 용어를 대중화하여 구체적으로 디자인 패턴을 구현했다. 이를 통해 개발자가 프레임워크의 핵심에 손대지 않고도 새로운 기능을 쉽게 만들고 배포하여 기능을 추가할 수 있도록 했다.\n- 구조\n![](https://velog.velcdn.com/images/sang-mini/post/e0a0ce03-d617-4f04-8602-5110aff64d88/image.png)\n\n - middleware에 처리를 위한 새로운 데이터가 수신되면 등록된 middleware 들이 비동기 순차 실행 흐름으로 호출된다. next 함수가 req - res 사이클에 걸려있는 다음 callback을 호출한다.\n-각 middleware는 데이터의 추가적인 처리를 중단시킬 수 있다. callback을 호출하지 않거나 오류를 전파하여 동작한다. \n\n- 새로운 middleware는 use()함수를 통해 등록할 수 있다. \n```jsx\n    const app = require('express')()\n    \n    app.use('/', (req, res, next) => {\n      req.headers['test-header'] = 1234\n      next()\n    })\n```\n\n\n### 활용\n이 미들웨어 패턴은 여러 객체 간 다대 다의 통신을 하나의 관리 포인트를 통하도록 만들어 관계를 단순하게 만들어준다.\n```jsx\n    import express from \"express\";\n    \n    const app = express();\n    \n    const urlLogger = (req, res, next) => {\n      console.log(`Path: ${req.path}`);\n      next();\n    };\n    \n    const timeLogger = (req, res, next) => {\n      const today = new Date();\n      const year = today.getFullYear();\n      const month = today.getMonth() + 1;\n      const day = today.getDate();\n      const date = `${year}.${month}.${day}`;\n      console.log(`Time: ${date}`);\n      next();\n    };\n    \n    const securityLogger = (req, res, next) => {\n      req.protocol === \"https\" ? console.log(\"Secure\") : console.log(\"Insecure\");\n      next();\n    };\n    \n    const protector = (req, res) => {\n      res.end();\n    };\n    \n    app.use(urlLogger, timeLogger, securityLogger);\n    app.get(\"/\", (req, res) => res.send(\"<h1>Home</h1>\"));\n    app.get(\"/protected\", protector, (req, res) => res.send(\"<h1>Protected</h1>\"));\n    \n    app.listen(process.env.PORT, () => `Listening!✅`);\n```\n [ CodeSandBox](https://codesandbox.io/s/a03blueprint-forked-89y5yu?file=/src/server.js)\n\n## 장단점\n- 장점\n  - object들 간 수정을 하지 않고 관계를 수정할 수 있다.\n  - object들 간의 관계의 복잡도, 의존성 및 결합도를 감소시킨다.\n다대 다의 복잡한 의존 관계를 풀어나감\n- 단점\n  - 중재자에 권한이 집중되어 있으므로 잘못된 중재자의 설계는 더 복잡한 객체를 생성할 수 있다. \n\n## 참고\n\n[Mediator/Middleware Pattern](https://www.patterns.dev/posts/mediator-pattern/)\n\n- JavaScript patterns - Stoyan Stefaonv\n- Node.js 디자인 패턴 바이블 - Mario Casciaro, Luciano Mammino\n",
          "commentCounts": 0
        },
        {
          "id": 11,
          "categoryIndex": 2,
          "part": "frontend",
          "topic": "Home",
          "contents": "> *Use a central mediator object to handle communication between components*\n\n## Mediator\n\n- 애플리케이션은 독립된 object들로 만들어진다. \nobject간의 통신은 유지보수가 쉽고 다른 object를 건드리지 않으면서, 애플리케이션의 일부분을 안전하게 수정할 수 있는 방식으로 이루어져야한다.\n    ![](https://velog.velcdn.com/images/sang-mini/post/4d7e63eb-a41d-4211-8238-ddd0c042170c/image.png)\n\n\n    \n\n- 애플리케이션의 크기가 커져가면서 더욱 더 많은 object들이 추가, 제거, 재배치된다. 이때 object들이 서로에 대해 너무 많은 정보를 아는 상태로 직접 통신하게 되면 서로간의 결합도가 높아져 바람직하지 않다. **object들이 강하게 결합되면, 다른 object들에 영향을 주지 않고 하나의 object를 수정하기가 어렵다.** \n\n- 우리는 object 간의 다방향 데이터를 처리해야 한다. 하지만 component가 많으면 component 간의 통신이 다소 혼란스러울 수 있다.\n- 이러한 이유로 component들이 서로 직접 통신하는 대신 mediator를 통하도록 한다. \n(mediator가 관제탑, component가 비행기라고 생각하면 된다.)\n\n\n>  _ component vs object\n 컴포넌트가 사람이 눈으로 확인할 수 있는 결과물이라면 객체는 사람이 눈으로 확인할 수 없는 작은 단위의 사물과 같다. 객체도 독립적으로 작동할 수 있지만 보통 다른 객체와 관계를 맺어 결과물을 제출한다. 다른 객체와 관계를 맺어 하나의 모듈이 되었으면 이 모듈이 곧 컴포넌트가 되기도 한다. 객체는 컴포넌트보다는 작은 단위의 기능을 수행한다. 컴포넌트는 독립적으로 작동하는 큰 단위의 모듈이다. 객체가 모여 컴포넌트가 된다. 컴포넌트는 사람이 직접적, 물질적으로 인식할 수 있는 대상이다._\n\n\n\n\n- **Mediator pattern**에서는 독립된 object들은 다른 object와 직접 통신하지 않고, **Mediator**를 거친다. \nJS에서 Mediator는 보통 object literal이나 function으로 구현된다. \n![](https://velog.velcdn.com/images/sang-mini/post/cfcaeff3-4401-4f25-adfc-6bdfdb44a4be/image.png)\n\n - ### 활용 \n 채팅방 기능\n```javascript\nclass ChatRoom {\n  logMessage(user, message) {\n    const time = new Date();\n    const sender = user.getName();\n\n    console.log(`${time} [${sender}]: ${message}`);\n  }\n}\n\n class User {\n  constructor(name, chatroom) {\n    this.name = name;\n    this.chatroom = chatroom;\n  }\n\n  getName() {\n    return this.name;\n  }\n\n  send(message) {\n    this.chatroom.logMessage(this, message);\n  }\n}\n```\n\n  [CodeSandBox](https://codesandbox.io/s/middleware-1-forked-jxts4w?file=/src/index.js)\n\n## Middleware\n\n- **Middleware** = middle software\nmiddleware는 **request와 respond 사이**에 있는 contoller다.\n- express가 middleware라는 용어를 대중화하여 구체적으로 디자인 패턴을 구현했다. 이를 통해 개발자가 프레임워크의 핵심에 손대지 않고도 새로운 기능을 쉽게 만들고 배포하여 기능을 추가할 수 있도록 했다.\n- 구조\n![](https://velog.velcdn.com/images/sang-mini/post/e0a0ce03-d617-4f04-8602-5110aff64d88/image.png)\n\n - middleware에 처리를 위한 새로운 데이터가 수신되면 등록된 middleware 들이 비동기 순차 실행 흐름으로 호출된다. next 함수가 req - res 사이클에 걸려있는 다음 callback을 호출한다.\n-각 middleware는 데이터의 추가적인 처리를 중단시킬 수 있다. callback을 호출하지 않거나 오류를 전파하여 동작한다. \n\n- 새로운 middleware는 use()함수를 통해 등록할 수 있다. \n```jsx\n    const app = require('express')()\n    \n    app.use('/', (req, res, next) => {\n      req.headers['test-header'] = 1234\n      next()\n    })\n```\n\n\n### 활용\n이 미들웨어 패턴은 여러 객체 간 다대 다의 통신을 하나의 관리 포인트를 통하도록 만들어 관계를 단순하게 만들어준다.\n```jsx\n    import express from \"express\";\n    \n    const app = express();\n    \n    const urlLogger = (req, res, next) => {\n      console.log(`Path: ${req.path}`);\n      next();\n    };\n    \n    const timeLogger = (req, res, next) => {\n      const today = new Date();\n      const year = today.getFullYear();\n      const month = today.getMonth() + 1;\n      const day = today.getDate();\n      const date = `${year}.${month}.${day}`;\n      console.log(`Time: ${date}`);\n      next();\n    };\n    \n    const securityLogger = (req, res, next) => {\n      req.protocol === \"https\" ? console.log(\"Secure\") : console.log(\"Insecure\");\n      next();\n    };\n    \n    const protector = (req, res) => {\n      res.end();\n    };\n    \n    app.use(urlLogger, timeLogger, securityLogger);\n    app.get(\"/\", (req, res) => res.send(\"<h1>Home</h1>\"));\n    app.get(\"/protected\", protector, (req, res) => res.send(\"<h1>Protected</h1>\"));\n    \n    app.listen(process.env.PORT, () => `Listening!✅`);\n```\n [ CodeSandBox](https://codesandbox.io/s/a03blueprint-forked-89y5yu?file=/src/server.js)\n\n## 장단점\n- 장점\n  - object들 간 수정을 하지 않고 관계를 수정할 수 있다.\n  - object들 간의 관계의 복잡도, 의존성 및 결합도를 감소시킨다.\n다대 다의 복잡한 의존 관계를 풀어나감\n- 단점\n  - 중재자에 권한이 집중되어 있으므로 잘못된 중재자의 설계는 더 복잡한 객체를 생성할 수 있다. \n\n## 참고\n\n[Mediator/Middleware Pattern](https://www.patterns.dev/posts/mediator-pattern/)\n\n- JavaScript patterns - Stoyan Stefaonv\n- Node.js 디자인 패턴 바이블 - Mario Casciaro, Luciano Mammino\n",
          "commentCounts": 0
        },
        {
          "id": 12,
          "categoryIndex": 3,
          "part": "frontend",
          "topic": "Other page",
          "contents": "> *Use a central mediator object to handle communication between components*\n\n## Mediator\n\n- 애플리케이션은 독립된 object들로 만들어진다. \nobject간의 통신은 유지보수가 쉽고 다른 object를 건드리지 않으면서, 애플리케이션의 일부분을 안전하게 수정할 수 있는 방식으로 이루어져야한다.\n    ![](https://velog.velcdn.com/images/sang-mini/post/4d7e63eb-a41d-4211-8238-ddd0c042170c/image.png)\n\n\n    \n\n- 애플리케이션의 크기가 커져가면서 더욱 더 많은 object들이 추가, 제거, 재배치된다. 이때 object들이 서로에 대해 너무 많은 정보를 아는 상태로 직접 통신하게 되면 서로간의 결합도가 높아져 바람직하지 않다. **object들이 강하게 결합되면, 다른 object들에 영향을 주지 않고 하나의 object를 수정하기가 어렵다.** \n\n- 우리는 object 간의 다방향 데이터를 처리해야 한다. 하지만 component가 많으면 component 간의 통신이 다소 혼란스러울 수 있다.\n- 이러한 이유로 component들이 서로 직접 통신하는 대신 mediator를 통하도록 한다. \n(mediator가 관제탑, component가 비행기라고 생각하면 된다.)\n\n\n>  _ component vs object\n 컴포넌트가 사람이 눈으로 확인할 수 있는 결과물이라면 객체는 사람이 눈으로 확인할 수 없는 작은 단위의 사물과 같다. 객체도 독립적으로 작동할 수 있지만 보통 다른 객체와 관계를 맺어 결과물을 제출한다. 다른 객체와 관계를 맺어 하나의 모듈이 되었으면 이 모듈이 곧 컴포넌트가 되기도 한다. 객체는 컴포넌트보다는 작은 단위의 기능을 수행한다. 컴포넌트는 독립적으로 작동하는 큰 단위의 모듈이다. 객체가 모여 컴포넌트가 된다. 컴포넌트는 사람이 직접적, 물질적으로 인식할 수 있는 대상이다._\n\n\n\n\n- **Mediator pattern**에서는 독립된 object들은 다른 object와 직접 통신하지 않고, **Mediator**를 거친다. \nJS에서 Mediator는 보통 object literal이나 function으로 구현된다. \n![](https://velog.velcdn.com/images/sang-mini/post/cfcaeff3-4401-4f25-adfc-6bdfdb44a4be/image.png)\n\n - ### 활용 \n 채팅방 기능\n```javascript\nclass ChatRoom {\n  logMessage(user, message) {\n    const time = new Date();\n    const sender = user.getName();\n\n    console.log(`${time} [${sender}]: ${message}`);\n  }\n}\n\n class User {\n  constructor(name, chatroom) {\n    this.name = name;\n    this.chatroom = chatroom;\n  }\n\n  getName() {\n    return this.name;\n  }\n\n  send(message) {\n    this.chatroom.logMessage(this, message);\n  }\n}\n```\n\n  [CodeSandBox](https://codesandbox.io/s/middleware-1-forked-jxts4w?file=/src/index.js)\n\n## Middleware\n\n- **Middleware** = middle software\nmiddleware는 **request와 respond 사이**에 있는 contoller다.\n- express가 middleware라는 용어를 대중화하여 구체적으로 디자인 패턴을 구현했다. 이를 통해 개발자가 프레임워크의 핵심에 손대지 않고도 새로운 기능을 쉽게 만들고 배포하여 기능을 추가할 수 있도록 했다.\n- 구조\n![](https://velog.velcdn.com/images/sang-mini/post/e0a0ce03-d617-4f04-8602-5110aff64d88/image.png)\n\n - middleware에 처리를 위한 새로운 데이터가 수신되면 등록된 middleware 들이 비동기 순차 실행 흐름으로 호출된다. next 함수가 req - res 사이클에 걸려있는 다음 callback을 호출한다.\n-각 middleware는 데이터의 추가적인 처리를 중단시킬 수 있다. callback을 호출하지 않거나 오류를 전파하여 동작한다. \n\n- 새로운 middleware는 use()함수를 통해 등록할 수 있다. \n```jsx\n    const app = require('express')()\n    \n    app.use('/', (req, res, next) => {\n      req.headers['test-header'] = 1234\n      next()\n    })\n```\n\n\n### 활용\n이 미들웨어 패턴은 여러 객체 간 다대 다의 통신을 하나의 관리 포인트를 통하도록 만들어 관계를 단순하게 만들어준다.\n```jsx\n    import express from \"express\";\n    \n    const app = express();\n    \n    const urlLogger = (req, res, next) => {\n      console.log(`Path: ${req.path}`);\n      next();\n    };\n    \n    const timeLogger = (req, res, next) => {\n      const today = new Date();\n      const year = today.getFullYear();\n      const month = today.getMonth() + 1;\n      const day = today.getDate();\n      const date = `${year}.${month}.${day}`;\n      console.log(`Time: ${date}`);\n      next();\n    };\n    \n    const securityLogger = (req, res, next) => {\n      req.protocol === \"https\" ? console.log(\"Secure\") : console.log(\"Insecure\");\n      next();\n    };\n    \n    const protector = (req, res) => {\n      res.end();\n    };\n    \n    app.use(urlLogger, timeLogger, securityLogger);\n    app.get(\"/\", (req, res) => res.send(\"<h1>Home</h1>\"));\n    app.get(\"/protected\", protector, (req, res) => res.send(\"<h1>Protected</h1>\"));\n    \n    app.listen(process.env.PORT, () => `Listening!✅`);\n```\n [ CodeSandBox](https://codesandbox.io/s/a03blueprint-forked-89y5yu?file=/src/server.js)\n\n## 장단점\n- 장점\n  - object들 간 수정을 하지 않고 관계를 수정할 수 있다.\n  - object들 간의 관계의 복잡도, 의존성 및 결합도를 감소시킨다.\n다대 다의 복잡한 의존 관계를 풀어나감\n- 단점\n  - 중재자에 권한이 집중되어 있으므로 잘못된 중재자의 설계는 더 복잡한 객체를 생성할 수 있다. \n\n## 참고\n\n[Mediator/Middleware Pattern](https://www.patterns.dev/posts/mediator-pattern/)\n\n- JavaScript patterns - Stoyan Stefaonv\n- Node.js 디자인 패턴 바이블 - Mario Casciaro, Luciano Mammino\n",
          "commentCounts": 0
        },
        {
          "id": 13,
          "categoryIndex": 4,
          "part": "frontend",
          "topic": "Join",
          "contents": "> *Use a central mediator object to handle communication between components*\n\n## Mediator\n\n- 애플리케이션은 독립된 object들로 만들어진다. \nobject간의 통신은 유지보수가 쉽고 다른 object를 건드리지 않으면서, 애플리케이션의 일부분을 안전하게 수정할 수 있는 방식으로 이루어져야한다.\n    ![](https://velog.velcdn.com/images/sang-mini/post/4d7e63eb-a41d-4211-8238-ddd0c042170c/image.png)\n\n\n    \n\n- 애플리케이션의 크기가 커져가면서 더욱 더 많은 object들이 추가, 제거, 재배치된다. 이때 object들이 서로에 대해 너무 많은 정보를 아는 상태로 직접 통신하게 되면 서로간의 결합도가 높아져 바람직하지 않다. **object들이 강하게 결합되면, 다른 object들에 영향을 주지 않고 하나의 object를 수정하기가 어렵다.** \n\n- 우리는 object 간의 다방향 데이터를 처리해야 한다. 하지만 component가 많으면 component 간의 통신이 다소 혼란스러울 수 있다.\n- 이러한 이유로 component들이 서로 직접 통신하는 대신 mediator를 통하도록 한다. \n(mediator가 관제탑, component가 비행기라고 생각하면 된다.)\n\n\n>  _ component vs object\n 컴포넌트가 사람이 눈으로 확인할 수 있는 결과물이라면 객체는 사람이 눈으로 확인할 수 없는 작은 단위의 사물과 같다. 객체도 독립적으로 작동할 수 있지만 보통 다른 객체와 관계를 맺어 결과물을 제출한다. 다른 객체와 관계를 맺어 하나의 모듈이 되었으면 이 모듈이 곧 컴포넌트가 되기도 한다. 객체는 컴포넌트보다는 작은 단위의 기능을 수행한다. 컴포넌트는 독립적으로 작동하는 큰 단위의 모듈이다. 객체가 모여 컴포넌트가 된다. 컴포넌트는 사람이 직접적, 물질적으로 인식할 수 있는 대상이다._\n\n\n\n\n- **Mediator pattern**에서는 독립된 object들은 다른 object와 직접 통신하지 않고, **Mediator**를 거친다. \nJS에서 Mediator는 보통 object literal이나 function으로 구현된다. \n![](https://velog.velcdn.com/images/sang-mini/post/cfcaeff3-4401-4f25-adfc-6bdfdb44a4be/image.png)\n\n - ### 활용 \n 채팅방 기능\n```javascript\nclass ChatRoom {\n  logMessage(user, message) {\n    const time = new Date();\n    const sender = user.getName();\n\n    console.log(`${time} [${sender}]: ${message}`);\n  }\n}\n\n class User {\n  constructor(name, chatroom) {\n    this.name = name;\n    this.chatroom = chatroom;\n  }\n\n  getName() {\n    return this.name;\n  }\n\n  send(message) {\n    this.chatroom.logMessage(this, message);\n  }\n}\n```\n\n  [CodeSandBox](https://codesandbox.io/s/middleware-1-forked-jxts4w?file=/src/index.js)\n\n## Middleware\n\n- **Middleware** = middle software\nmiddleware는 **request와 respond 사이**에 있는 contoller다.\n- express가 middleware라는 용어를 대중화하여 구체적으로 디자인 패턴을 구현했다. 이를 통해 개발자가 프레임워크의 핵심에 손대지 않고도 새로운 기능을 쉽게 만들고 배포하여 기능을 추가할 수 있도록 했다.\n- 구조\n![](https://velog.velcdn.com/images/sang-mini/post/e0a0ce03-d617-4f04-8602-5110aff64d88/image.png)\n\n - middleware에 처리를 위한 새로운 데이터가 수신되면 등록된 middleware 들이 비동기 순차 실행 흐름으로 호출된다. next 함수가 req - res 사이클에 걸려있는 다음 callback을 호출한다.\n-각 middleware는 데이터의 추가적인 처리를 중단시킬 수 있다. callback을 호출하지 않거나 오류를 전파하여 동작한다. \n\n- 새로운 middleware는 use()함수를 통해 등록할 수 있다. \n```jsx\n    const app = require('express')()\n    \n    app.use('/', (req, res, next) => {\n      req.headers['test-header'] = 1234\n      next()\n    })\n```\n\n\n### 활용\n이 미들웨어 패턴은 여러 객체 간 다대 다의 통신을 하나의 관리 포인트를 통하도록 만들어 관계를 단순하게 만들어준다.\n```jsx\n    import express from \"express\";\n    \n    const app = express();\n    \n    const urlLogger = (req, res, next) => {\n      console.log(`Path: ${req.path}`);\n      next();\n    };\n    \n    const timeLogger = (req, res, next) => {\n      const today = new Date();\n      const year = today.getFullYear();\n      const month = today.getMonth() + 1;\n      const day = today.getDate();\n      const date = `${year}.${month}.${day}`;\n      console.log(`Time: ${date}`);\n      next();\n    };\n    \n    const securityLogger = (req, res, next) => {\n      req.protocol === \"https\" ? console.log(\"Secure\") : console.log(\"Insecure\");\n      next();\n    };\n    \n    const protector = (req, res) => {\n      res.end();\n    };\n    \n    app.use(urlLogger, timeLogger, securityLogger);\n    app.get(\"/\", (req, res) => res.send(\"<h1>Home</h1>\"));\n    app.get(\"/protected\", protector, (req, res) => res.send(\"<h1>Protected</h1>\"));\n    \n    app.listen(process.env.PORT, () => `Listening!✅`);\n```\n [ CodeSandBox](https://codesandbox.io/s/a03blueprint-forked-89y5yu?file=/src/server.js)\n\n## 장단점\n- 장점\n  - object들 간 수정을 하지 않고 관계를 수정할 수 있다.\n  - object들 간의 관계의 복잡도, 의존성 및 결합도를 감소시킨다.\n다대 다의 복잡한 의존 관계를 풀어나감\n- 단점\n  - 중재자에 권한이 집중되어 있으므로 잘못된 중재자의 설계는 더 복잡한 객체를 생성할 수 있다. \n\n## 참고\n\n[Mediator/Middleware Pattern](https://www.patterns.dev/posts/mediator-pattern/)\n\n- JavaScript patterns - Stoyan Stefaonv\n- Node.js 디자인 패턴 바이블 - Mario Casciaro, Luciano Mammino\n",
          "commentCounts": 0
        },
        {
          "id": 14,
          "categoryIndex": 5,
          "part": "frontend",
          "topic": "Profile",
          "contents": "> *Use a central mediator object to handle communication between components*\n\n## Mediator\n\n- 애플리케이션은 독립된 object들로 만들어진다. \nobject간의 통신은 유지보수가 쉽고 다른 object를 건드리지 않으면서, 애플리케이션의 일부분을 안전하게 수정할 수 있는 방식으로 이루어져야한다.\n    ![](https://velog.velcdn.com/images/sang-mini/post/4d7e63eb-a41d-4211-8238-ddd0c042170c/image.png)\n\n\n    \n\n- 애플리케이션의 크기가 커져가면서 더욱 더 많은 object들이 추가, 제거, 재배치된다. 이때 object들이 서로에 대해 너무 많은 정보를 아는 상태로 직접 통신하게 되면 서로간의 결합도가 높아져 바람직하지 않다. **object들이 강하게 결합되면, 다른 object들에 영향을 주지 않고 하나의 object를 수정하기가 어렵다.** \n\n- 우리는 object 간의 다방향 데이터를 처리해야 한다. 하지만 component가 많으면 component 간의 통신이 다소 혼란스러울 수 있다.\n- 이러한 이유로 component들이 서로 직접 통신하는 대신 mediator를 통하도록 한다. \n(mediator가 관제탑, component가 비행기라고 생각하면 된다.)\n\n\n>  _ component vs object\n 컴포넌트가 사람이 눈으로 확인할 수 있는 결과물이라면 객체는 사람이 눈으로 확인할 수 없는 작은 단위의 사물과 같다. 객체도 독립적으로 작동할 수 있지만 보통 다른 객체와 관계를 맺어 결과물을 제출한다. 다른 객체와 관계를 맺어 하나의 모듈이 되었으면 이 모듈이 곧 컴포넌트가 되기도 한다. 객체는 컴포넌트보다는 작은 단위의 기능을 수행한다. 컴포넌트는 독립적으로 작동하는 큰 단위의 모듈이다. 객체가 모여 컴포넌트가 된다. 컴포넌트는 사람이 직접적, 물질적으로 인식할 수 있는 대상이다._\n\n\n\n\n- **Mediator pattern**에서는 독립된 object들은 다른 object와 직접 통신하지 않고, **Mediator**를 거친다. \nJS에서 Mediator는 보통 object literal이나 function으로 구현된다. \n![](https://velog.velcdn.com/images/sang-mini/post/cfcaeff3-4401-4f25-adfc-6bdfdb44a4be/image.png)\n\n - ### 활용 \n 채팅방 기능\n```javascript\nclass ChatRoom {\n  logMessage(user, message) {\n    const time = new Date();\n    const sender = user.getName();\n\n    console.log(`${time} [${sender}]: ${message}`);\n  }\n}\n\n class User {\n  constructor(name, chatroom) {\n    this.name = name;\n    this.chatroom = chatroom;\n  }\n\n  getName() {\n    return this.name;\n  }\n\n  send(message) {\n    this.chatroom.logMessage(this, message);\n  }\n}\n```\n\n  [CodeSandBox](https://codesandbox.io/s/middleware-1-forked-jxts4w?file=/src/index.js)\n\n## Middleware\n\n- **Middleware** = middle software\nmiddleware는 **request와 respond 사이**에 있는 contoller다.\n- express가 middleware라는 용어를 대중화하여 구체적으로 디자인 패턴을 구현했다. 이를 통해 개발자가 프레임워크의 핵심에 손대지 않고도 새로운 기능을 쉽게 만들고 배포하여 기능을 추가할 수 있도록 했다.\n- 구조\n![](https://velog.velcdn.com/images/sang-mini/post/e0a0ce03-d617-4f04-8602-5110aff64d88/image.png)\n\n - middleware에 처리를 위한 새로운 데이터가 수신되면 등록된 middleware 들이 비동기 순차 실행 흐름으로 호출된다. next 함수가 req - res 사이클에 걸려있는 다음 callback을 호출한다.\n-각 middleware는 데이터의 추가적인 처리를 중단시킬 수 있다. callback을 호출하지 않거나 오류를 전파하여 동작한다. \n\n- 새로운 middleware는 use()함수를 통해 등록할 수 있다. \n```jsx\n    const app = require('express')()\n    \n    app.use('/', (req, res, next) => {\n      req.headers['test-header'] = 1234\n      next()\n    })\n```\n\n\n### 활용\n이 미들웨어 패턴은 여러 객체 간 다대 다의 통신을 하나의 관리 포인트를 통하도록 만들어 관계를 단순하게 만들어준다.\n```jsx\n    import express from \"express\";\n    \n    const app = express();\n    \n    const urlLogger = (req, res, next) => {\n      console.log(`Path: ${req.path}`);\n      next();\n    };\n    \n    const timeLogger = (req, res, next) => {\n      const today = new Date();\n      const year = today.getFullYear();\n      const month = today.getMonth() + 1;\n      const day = today.getDate();\n      const date = `${year}.${month}.${day}`;\n      console.log(`Time: ${date}`);\n      next();\n    };\n    \n    const securityLogger = (req, res, next) => {\n      req.protocol === \"https\" ? console.log(\"Secure\") : console.log(\"Insecure\");\n      next();\n    };\n    \n    const protector = (req, res) => {\n      res.end();\n    };\n    \n    app.use(urlLogger, timeLogger, securityLogger);\n    app.get(\"/\", (req, res) => res.send(\"<h1>Home</h1>\"));\n    app.get(\"/protected\", protector, (req, res) => res.send(\"<h1>Protected</h1>\"));\n    \n    app.listen(process.env.PORT, () => `Listening!✅`);\n```\n [ CodeSandBox](https://codesandbox.io/s/a03blueprint-forked-89y5yu?file=/src/server.js)\n\n## 장단점\n- 장점\n  - object들 간 수정을 하지 않고 관계를 수정할 수 있다.\n  - object들 간의 관계의 복잡도, 의존성 및 결합도를 감소시킨다.\n다대 다의 복잡한 의존 관계를 풀어나감\n- 단점\n  - 중재자에 권한이 집중되어 있으므로 잘못된 중재자의 설계는 더 복잡한 객체를 생성할 수 있다. \n\n## 참고\n\n[Mediator/Middleware Pattern](https://www.patterns.dev/posts/mediator-pattern/)\n\n- JavaScript patterns - Stoyan Stefaonv\n- Node.js 디자인 패턴 바이블 - Mario Casciaro, Luciano Mammino\n",
          "commentCounts": 0
        },
        {
          "id": 15,
          "categoryIndex": 6,
          "part": "frontend",
          "topic": "Board",
          "contents": "> *Use a central mediator object to handle communication between components*\n\n## Mediator\n\n- 애플리케이션은 독립된 object들로 만들어진다. \nobject간의 통신은 유지보수가 쉽고 다른 object를 건드리지 않으면서, 애플리케이션의 일부분을 안전하게 수정할 수 있는 방식으로 이루어져야한다.\n    ![](https://velog.velcdn.com/images/sang-mini/post/4d7e63eb-a41d-4211-8238-ddd0c042170c/image.png)\n\n\n    \n\n- 애플리케이션의 크기가 커져가면서 더욱 더 많은 object들이 추가, 제거, 재배치된다. 이때 object들이 서로에 대해 너무 많은 정보를 아는 상태로 직접 통신하게 되면 서로간의 결합도가 높아져 바람직하지 않다. **object들이 강하게 결합되면, 다른 object들에 영향을 주지 않고 하나의 object를 수정하기가 어렵다.** \n\n- 우리는 object 간의 다방향 데이터를 처리해야 한다. 하지만 component가 많으면 component 간의 통신이 다소 혼란스러울 수 있다.\n- 이러한 이유로 component들이 서로 직접 통신하는 대신 mediator를 통하도록 한다. \n(mediator가 관제탑, component가 비행기라고 생각하면 된다.)\n\n\n>  _ component vs object\n 컴포넌트가 사람이 눈으로 확인할 수 있는 결과물이라면 객체는 사람이 눈으로 확인할 수 없는 작은 단위의 사물과 같다. 객체도 독립적으로 작동할 수 있지만 보통 다른 객체와 관계를 맺어 결과물을 제출한다. 다른 객체와 관계를 맺어 하나의 모듈이 되었으면 이 모듈이 곧 컴포넌트가 되기도 한다. 객체는 컴포넌트보다는 작은 단위의 기능을 수행한다. 컴포넌트는 독립적으로 작동하는 큰 단위의 모듈이다. 객체가 모여 컴포넌트가 된다. 컴포넌트는 사람이 직접적, 물질적으로 인식할 수 있는 대상이다._\n\n\n\n\n- **Mediator pattern**에서는 독립된 object들은 다른 object와 직접 통신하지 않고, **Mediator**를 거친다. \nJS에서 Mediator는 보통 object literal이나 function으로 구현된다. \n![](https://velog.velcdn.com/images/sang-mini/post/cfcaeff3-4401-4f25-adfc-6bdfdb44a4be/image.png)\n\n - ### 활용 \n 채팅방 기능\n```javascript\nclass ChatRoom {\n  logMessage(user, message) {\n    const time = new Date();\n    const sender = user.getName();\n\n    console.log(`${time} [${sender}]: ${message}`);\n  }\n}\n\n class User {\n  constructor(name, chatroom) {\n    this.name = name;\n    this.chatroom = chatroom;\n  }\n\n  getName() {\n    return this.name;\n  }\n\n  send(message) {\n    this.chatroom.logMessage(this, message);\n  }\n}\n```\n\n  [CodeSandBox](https://codesandbox.io/s/middleware-1-forked-jxts4w?file=/src/index.js)\n\n## Middleware\n\n- **Middleware** = middle software\nmiddleware는 **request와 respond 사이**에 있는 contoller다.\n- express가 middleware라는 용어를 대중화하여 구체적으로 디자인 패턴을 구현했다. 이를 통해 개발자가 프레임워크의 핵심에 손대지 않고도 새로운 기능을 쉽게 만들고 배포하여 기능을 추가할 수 있도록 했다.\n- 구조\n![](https://velog.velcdn.com/images/sang-mini/post/e0a0ce03-d617-4f04-8602-5110aff64d88/image.png)\n\n - middleware에 처리를 위한 새로운 데이터가 수신되면 등록된 middleware 들이 비동기 순차 실행 흐름으로 호출된다. next 함수가 req - res 사이클에 걸려있는 다음 callback을 호출한다.\n-각 middleware는 데이터의 추가적인 처리를 중단시킬 수 있다. callback을 호출하지 않거나 오류를 전파하여 동작한다. \n\n- 새로운 middleware는 use()함수를 통해 등록할 수 있다. \n```jsx\n    const app = require('express')()\n    \n    app.use('/', (req, res, next) => {\n      req.headers['test-header'] = 1234\n      next()\n    })\n```\n\n\n### 활용\n이 미들웨어 패턴은 여러 객체 간 다대 다의 통신을 하나의 관리 포인트를 통하도록 만들어 관계를 단순하게 만들어준다.\n```jsx\n    import express from \"express\";\n    \n    const app = express();\n    \n    const urlLogger = (req, res, next) => {\n      console.log(`Path: ${req.path}`);\n      next();\n    };\n    \n    const timeLogger = (req, res, next) => {\n      const today = new Date();\n      const year = today.getFullYear();\n      const month = today.getMonth() + 1;\n      const day = today.getDate();\n      const date = `${year}.${month}.${day}`;\n      console.log(`Time: ${date}`);\n      next();\n    };\n    \n    const securityLogger = (req, res, next) => {\n      req.protocol === \"https\" ? console.log(\"Secure\") : console.log(\"Insecure\");\n      next();\n    };\n    \n    const protector = (req, res) => {\n      res.end();\n    };\n    \n    app.use(urlLogger, timeLogger, securityLogger);\n    app.get(\"/\", (req, res) => res.send(\"<h1>Home</h1>\"));\n    app.get(\"/protected\", protector, (req, res) => res.send(\"<h1>Protected</h1>\"));\n    \n    app.listen(process.env.PORT, () => `Listening!✅`);\n```\n [ CodeSandBox](https://codesandbox.io/s/a03blueprint-forked-89y5yu?file=/src/server.js)\n\n## 장단점\n- 장점\n  - object들 간 수정을 하지 않고 관계를 수정할 수 있다.\n  - object들 간의 관계의 복잡도, 의존성 및 결합도를 감소시킨다.\n다대 다의 복잡한 의존 관계를 풀어나감\n- 단점\n  - 중재자에 권한이 집중되어 있으므로 잘못된 중재자의 설계는 더 복잡한 객체를 생성할 수 있다. \n\n## 참고\n\n[Mediator/Middleware Pattern](https://www.patterns.dev/posts/mediator-pattern/)\n\n- JavaScript patterns - Stoyan Stefaonv\n- Node.js 디자인 패턴 바이블 - Mario Casciaro, Luciano Mammino\n",
          "commentCounts": 0
        }
      ],
      "Backend": [
        {
          "id": 16,
          "categoryIndex": 0,
          "part": "backend",
          "topic": "초기설정",
          "contents": "> *Use a central mediator object to handle communication between components*\n\n## Mediator\n\n- 애플리케이션은 독립된 object들로 만들어진다. \nobject간의 통신은 유지보수가 쉽고 다른 object를 건드리지 않으면서, 애플리케이션의 일부분을 안전하게 수정할 수 있는 방식으로 이루어져야한다.\n    ![](https://velog.velcdn.com/images/sang-mini/post/4d7e63eb-a41d-4211-8238-ddd0c042170c/image.png)\n\n\n    \n\n- 애플리케이션의 크기가 커져가면서 더욱 더 많은 object들이 추가, 제거, 재배치된다. 이때 object들이 서로에 대해 너무 많은 정보를 아는 상태로 직접 통신하게 되면 서로간의 결합도가 높아져 바람직하지 않다. **object들이 강하게 결합되면, 다른 object들에 영향을 주지 않고 하나의 object를 수정하기가 어렵다.** \n\n- 우리는 object 간의 다방향 데이터를 처리해야 한다. 하지만 component가 많으면 component 간의 통신이 다소 혼란스러울 수 있다.\n- 이러한 이유로 component들이 서로 직접 통신하는 대신 mediator를 통하도록 한다. \n(mediator가 관제탑, component가 비행기라고 생각하면 된다.)\n\n\n>  _ component vs object\n 컴포넌트가 사람이 눈으로 확인할 수 있는 결과물이라면 객체는 사람이 눈으로 확인할 수 없는 작은 단위의 사물과 같다. 객체도 독립적으로 작동할 수 있지만 보통 다른 객체와 관계를 맺어 결과물을 제출한다. 다른 객체와 관계를 맺어 하나의 모듈이 되었으면 이 모듈이 곧 컴포넌트가 되기도 한다. 객체는 컴포넌트보다는 작은 단위의 기능을 수행한다. 컴포넌트는 독립적으로 작동하는 큰 단위의 모듈이다. 객체가 모여 컴포넌트가 된다. 컴포넌트는 사람이 직접적, 물질적으로 인식할 수 있는 대상이다._\n\n\n\n\n- **Mediator pattern**에서는 독립된 object들은 다른 object와 직접 통신하지 않고, **Mediator**를 거친다. \nJS에서 Mediator는 보통 object literal이나 function으로 구현된다. \n![](https://velog.velcdn.com/images/sang-mini/post/cfcaeff3-4401-4f25-adfc-6bdfdb44a4be/image.png)\n\n - ### 활용 \n 채팅방 기능\n```javascript\nclass ChatRoom {\n  logMessage(user, message) {\n    const time = new Date();\n    const sender = user.getName();\n\n    console.log(`${time} [${sender}]: ${message}`);\n  }\n}\n\n class User {\n  constructor(name, chatroom) {\n    this.name = name;\n    this.chatroom = chatroom;\n  }\n\n  getName() {\n    return this.name;\n  }\n\n  send(message) {\n    this.chatroom.logMessage(this, message);\n  }\n}\n```\n\n  [CodeSandBox](https://codesandbox.io/s/middleware-1-forked-jxts4w?file=/src/index.js)\n\n## Middleware\n\n- **Middleware** = middle software\nmiddleware는 **request와 respond 사이**에 있는 contoller다.\n- express가 middleware라는 용어를 대중화하여 구체적으로 디자인 패턴을 구현했다. 이를 통해 개발자가 프레임워크의 핵심에 손대지 않고도 새로운 기능을 쉽게 만들고 배포하여 기능을 추가할 수 있도록 했다.\n- 구조\n![](https://velog.velcdn.com/images/sang-mini/post/e0a0ce03-d617-4f04-8602-5110aff64d88/image.png)\n\n - middleware에 처리를 위한 새로운 데이터가 수신되면 등록된 middleware 들이 비동기 순차 실행 흐름으로 호출된다. next 함수가 req - res 사이클에 걸려있는 다음 callback을 호출한다.\n-각 middleware는 데이터의 추가적인 처리를 중단시킬 수 있다. callback을 호출하지 않거나 오류를 전파하여 동작한다. \n\n- 새로운 middleware는 use()함수를 통해 등록할 수 있다. \n```jsx\n    const app = require('express')()\n    \n    app.use('/', (req, res, next) => {\n      req.headers['test-header'] = 1234\n      next()\n    })\n```\n\n\n### 활용\n이 미들웨어 패턴은 여러 객체 간 다대 다의 통신을 하나의 관리 포인트를 통하도록 만들어 관계를 단순하게 만들어준다.\n```jsx\n    import express from \"express\";\n    \n    const app = express();\n    \n    const urlLogger = (req, res, next) => {\n      console.log(`Path: ${req.path}`);\n      next();\n    };\n    \n    const timeLogger = (req, res, next) => {\n      const today = new Date();\n      const year = today.getFullYear();\n      const month = today.getMonth() + 1;\n      const day = today.getDate();\n      const date = `${year}.${month}.${day}`;\n      console.log(`Time: ${date}`);\n      next();\n    };\n    \n    const securityLogger = (req, res, next) => {\n      req.protocol === \"https\" ? console.log(\"Secure\") : console.log(\"Insecure\");\n      next();\n    };\n    \n    const protector = (req, res) => {\n      res.end();\n    };\n    \n    app.use(urlLogger, timeLogger, securityLogger);\n    app.get(\"/\", (req, res) => res.send(\"<h1>Home</h1>\"));\n    app.get(\"/protected\", protector, (req, res) => res.send(\"<h1>Protected</h1>\"));\n    \n    app.listen(process.env.PORT, () => `Listening!✅`);\n```\n [ CodeSandBox](https://codesandbox.io/s/a03blueprint-forked-89y5yu?file=/src/server.js)\n\n## 장단점\n- 장점\n  - object들 간 수정을 하지 않고 관계를 수정할 수 있다.\n  - object들 간의 관계의 복잡도, 의존성 및 결합도를 감소시킨다.\n다대 다의 복잡한 의존 관계를 풀어나감\n- 단점\n  - 중재자에 권한이 집중되어 있으므로 잘못된 중재자의 설계는 더 복잡한 객체를 생성할 수 있다. \n\n## 참고\n\n[Mediator/Middleware Pattern](https://www.patterns.dev/posts/mediator-pattern/)\n\n- JavaScript patterns - Stoyan Stefaonv\n- Node.js 디자인 패턴 바이블 - Mario Casciaro, Luciano Mammino\n",
          "commentCounts": 0
        },
        {
          "id": 17,
          "categoryIndex": 1,
          "part": "backend",
          "topic": "Router setting",
          "contents": "",
          "commentCounts": 1
        },
        {
          "id": 18,
          "categoryIndex": 2,
          "part": "backend",
          "topic": "DB구상",
          "contents": "",
          "commentCounts": 1
        },
        {
          "id": 19,
          "categoryIndex": 3,
          "part": "backend",
          "topic": "DB구현",
          "contents": "",
          "commentCounts": 1
        },
        {
          "id": 20,
          "categoryIndex": 4,
          "part": "backend",
          "topic": "상세기능 구현",
          "contents": "> *Use a central mediator object to handle communication between components*\n\n## Mediator\n\n- 애플리케이션은 독립된 object들로 만들어진다. \nobject간의 통신은 유지보수가 쉽고 다른 object를 건드리지 않으면서, 애플리케이션의 일부분을 안전하게 수정할 수 있는 방식으로 이루어져야한다.\n    ![](https://velog.velcdn.com/images/sang-mini/post/4d7e63eb-a41d-4211-8238-ddd0c042170c/image.png)\n\n\n    \n\n- 애플리케이션의 크기가 커져가면서 더욱 더 많은 object들이 추가, 제거, 재배치된다. 이때 object들이 서로에 대해 너무 많은 정보를 아는 상태로 직접 통신하게 되면 서로간의 결합도가 높아져 바람직하지 않다. **object들이 강하게 결합되면, 다른 object들에 영향을 주지 않고 하나의 object를 수정하기가 어렵다.** \n\n- 우리는 object 간의 다방향 데이터를 처리해야 한다. 하지만 component가 많으면 component 간의 통신이 다소 혼란스러울 수 있다.\n- 이러한 이유로 component들이 서로 직접 통신하는 대신 mediator를 통하도록 한다. \n(mediator가 관제탑, component가 비행기라고 생각하면 된다.)\n\n\n>  _ component vs object\n 컴포넌트가 사람이 눈으로 확인할 수 있는 결과물이라면 객체는 사람이 눈으로 확인할 수 없는 작은 단위의 사물과 같다. 객체도 독립적으로 작동할 수 있지만 보통 다른 객체와 관계를 맺어 결과물을 제출한다. 다른 객체와 관계를 맺어 하나의 모듈이 되었으면 이 모듈이 곧 컴포넌트가 되기도 한다. 객체는 컴포넌트보다는 작은 단위의 기능을 수행한다. 컴포넌트는 독립적으로 작동하는 큰 단위의 모듈이다. 객체가 모여 컴포넌트가 된다. 컴포넌트는 사람이 직접적, 물질적으로 인식할 수 있는 대상이다._\n\n\n\n\n- **Mediator pattern**에서는 독립된 object들은 다른 object와 직접 통신하지 않고, **Mediator**를 거친다. \nJS에서 Mediator는 보통 object literal이나 function으로 구현된다. \n![](https://velog.velcdn.com/images/sang-mini/post/cfcaeff3-4401-4f25-adfc-6bdfdb44a4be/image.png)\n\n - ### 활용 \n 채팅방 기능\n```javascript\nclass ChatRoom {\n  logMessage(user, message) {\n    const time = new Date();\n    const sender = user.getName();\n\n    console.log(`${time} [${sender}]: ${message}`);\n  }\n}\n\n class User {\n  constructor(name, chatroom) {\n    this.name = name;\n    this.chatroom = chatroom;\n  }\n\n  getName() {\n    return this.name;\n  }\n\n  send(message) {\n    this.chatroom.logMessage(this, message);\n  }\n}\n```\n\n  [CodeSandBox](https://codesandbox.io/s/middleware-1-forked-jxts4w?file=/src/index.js)\n\n## Middleware\n\n- **Middleware** = middle software\nmiddleware는 **request와 respond 사이**에 있는 contoller다.\n- express가 middleware라는 용어를 대중화하여 구체적으로 디자인 패턴을 구현했다. 이를 통해 개발자가 프레임워크의 핵심에 손대지 않고도 새로운 기능을 쉽게 만들고 배포하여 기능을 추가할 수 있도록 했다.\n- 구조\n![](https://velog.velcdn.com/images/sang-mini/post/e0a0ce03-d617-4f04-8602-5110aff64d88/image.png)\n\n - middleware에 처리를 위한 새로운 데이터가 수신되면 등록된 middleware 들이 비동기 순차 실행 흐름으로 호출된다. next 함수가 req - res 사이클에 걸려있는 다음 callback을 호출한다.\n-각 middleware는 데이터의 추가적인 처리를 중단시킬 수 있다. callback을 호출하지 않거나 오류를 전파하여 동작한다. \n\n- 새로운 middleware는 use()함수를 통해 등록할 수 있다. \n```jsx\n    const app = require('express')()\n    \n    app.use('/', (req, res, next) => {\n      req.headers['test-header'] = 1234\n      next()\n    })\n```\n\n\n### 활용\n이 미들웨어 패턴은 여러 객체 간 다대 다의 통신을 하나의 관리 포인트를 통하도록 만들어 관계를 단순하게 만들어준다.\n```jsx\n    import express from \"express\";\n    \n    const app = express();\n    \n    const urlLogger = (req, res, next) => {\n      console.log(`Path: ${req.path}`);\n      next();\n    };\n    \n    const timeLogger = (req, res, next) => {\n      const today = new Date();\n      const year = today.getFullYear();\n      const month = today.getMonth() + 1;\n      const day = today.getDate();\n      const date = `${year}.${month}.${day}`;\n      console.log(`Time: ${date}`);\n      next();\n    };\n    \n    const securityLogger = (req, res, next) => {\n      req.protocol === \"https\" ? console.log(\"Secure\") : console.log(\"Insecure\");\n      next();\n    };\n    \n    const protector = (req, res) => {\n      res.end();\n    };\n    \n    app.use(urlLogger, timeLogger, securityLogger);\n    app.get(\"/\", (req, res) => res.send(\"<h1>Home</h1>\"));\n    app.get(\"/protected\", protector, (req, res) => res.send(\"<h1>Protected</h1>\"));\n    \n    app.listen(process.env.PORT, () => `Listening!✅`);\n```\n [ CodeSandBox](https://codesandbox.io/s/a03blueprint-forked-89y5yu?file=/src/server.js)\n\n## 장단점\n- 장점\n  - object들 간 수정을 하지 않고 관계를 수정할 수 있다.\n  - object들 간의 관계의 복잡도, 의존성 및 결합도를 감소시킨다.\n다대 다의 복잡한 의존 관계를 풀어나감\n- 단점\n  - 중재자에 권한이 집중되어 있으므로 잘못된 중재자의 설계는 더 복잡한 객체를 생성할 수 있다. \n\n## 참고\n\n[Mediator/Middleware Pattern](https://www.patterns.dev/posts/mediator-pattern/)\n\n- JavaScript patterns - Stoyan Stefaonv\n- Node.js 디자인 패턴 바이블 - Mario Casciaro, Luciano Mammino\n",
          "commentCounts": 0
        },
        {
          "id": 21,
          "categoryIndex": 5,
          "part": "backend",
          "topic": "배포환경설정",
          "contents": "> *Use a central mediator object to handle communication between components*\n\n## Mediator\n\n- 애플리케이션은 독립된 object들로 만들어진다. \nobject간의 통신은 유지보수가 쉽고 다른 object를 건드리지 않으면서, 애플리케이션의 일부분을 안전하게 수정할 수 있는 방식으로 이루어져야한다.\n    ![](https://velog.velcdn.com/images/sang-mini/post/4d7e63eb-a41d-4211-8238-ddd0c042170c/image.png)\n\n\n    \n\n- 애플리케이션의 크기가 커져가면서 더욱 더 많은 object들이 추가, 제거, 재배치된다. 이때 object들이 서로에 대해 너무 많은 정보를 아는 상태로 직접 통신하게 되면 서로간의 결합도가 높아져 바람직하지 않다. **object들이 강하게 결합되면, 다른 object들에 영향을 주지 않고 하나의 object를 수정하기가 어렵다.** \n\n- 우리는 object 간의 다방향 데이터를 처리해야 한다. 하지만 component가 많으면 component 간의 통신이 다소 혼란스러울 수 있다.\n- 이러한 이유로 component들이 서로 직접 통신하는 대신 mediator를 통하도록 한다. \n(mediator가 관제탑, component가 비행기라고 생각하면 된다.)\n\n\n>  _ component vs object\n 컴포넌트가 사람이 눈으로 확인할 수 있는 결과물이라면 객체는 사람이 눈으로 확인할 수 없는 작은 단위의 사물과 같다. 객체도 독립적으로 작동할 수 있지만 보통 다른 객체와 관계를 맺어 결과물을 제출한다. 다른 객체와 관계를 맺어 하나의 모듈이 되었으면 이 모듈이 곧 컴포넌트가 되기도 한다. 객체는 컴포넌트보다는 작은 단위의 기능을 수행한다. 컴포넌트는 독립적으로 작동하는 큰 단위의 모듈이다. 객체가 모여 컴포넌트가 된다. 컴포넌트는 사람이 직접적, 물질적으로 인식할 수 있는 대상이다._\n\n\n\n\n- **Mediator pattern**에서는 독립된 object들은 다른 object와 직접 통신하지 않고, **Mediator**를 거친다. \nJS에서 Mediator는 보통 object literal이나 function으로 구현된다. \n![](https://velog.velcdn.com/images/sang-mini/post/cfcaeff3-4401-4f25-adfc-6bdfdb44a4be/image.png)\n\n - ### 활용 \n 채팅방 기능\n```javascript\nclass ChatRoom {\n  logMessage(user, message) {\n    const time = new Date();\n    const sender = user.getName();\n\n    console.log(`${time} [${sender}]: ${message}`);\n  }\n}\n\n class User {\n  constructor(name, chatroom) {\n    this.name = name;\n    this.chatroom = chatroom;\n  }\n\n  getName() {\n    return this.name;\n  }\n\n  send(message) {\n    this.chatroom.logMessage(this, message);\n  }\n}\n```\n\n  [CodeSandBox](https://codesandbox.io/s/middleware-1-forked-jxts4w?file=/src/index.js)\n\n## Middleware\n\n- **Middleware** = middle software\nmiddleware는 **request와 respond 사이**에 있는 contoller다.\n- express가 middleware라는 용어를 대중화하여 구체적으로 디자인 패턴을 구현했다. 이를 통해 개발자가 프레임워크의 핵심에 손대지 않고도 새로운 기능을 쉽게 만들고 배포하여 기능을 추가할 수 있도록 했다.\n- 구조\n![](https://velog.velcdn.com/images/sang-mini/post/e0a0ce03-d617-4f04-8602-5110aff64d88/image.png)\n\n - middleware에 처리를 위한 새로운 데이터가 수신되면 등록된 middleware 들이 비동기 순차 실행 흐름으로 호출된다. next 함수가 req - res 사이클에 걸려있는 다음 callback을 호출한다.\n-각 middleware는 데이터의 추가적인 처리를 중단시킬 수 있다. callback을 호출하지 않거나 오류를 전파하여 동작한다. \n\n- 새로운 middleware는 use()함수를 통해 등록할 수 있다. \n```jsx\n    const app = require('express')()\n    \n    app.use('/', (req, res, next) => {\n      req.headers['test-header'] = 1234\n      next()\n    })\n```\n\n\n### 활용\n이 미들웨어 패턴은 여러 객체 간 다대 다의 통신을 하나의 관리 포인트를 통하도록 만들어 관계를 단순하게 만들어준다.\n```jsx\n    import express from \"express\";\n    \n    const app = express();\n    \n    const urlLogger = (req, res, next) => {\n      console.log(`Path: ${req.path}`);\n      next();\n    };\n    \n    const timeLogger = (req, res, next) => {\n      const today = new Date();\n      const year = today.getFullYear();\n      const month = today.getMonth() + 1;\n      const day = today.getDate();\n      const date = `${year}.${month}.${day}`;\n      console.log(`Time: ${date}`);\n      next();\n    };\n    \n    const securityLogger = (req, res, next) => {\n      req.protocol === \"https\" ? console.log(\"Secure\") : console.log(\"Insecure\");\n      next();\n    };\n    \n    const protector = (req, res) => {\n      res.end();\n    };\n    \n    app.use(urlLogger, timeLogger, securityLogger);\n    app.get(\"/\", (req, res) => res.send(\"<h1>Home</h1>\"));\n    app.get(\"/protected\", protector, (req, res) => res.send(\"<h1>Protected</h1>\"));\n    \n    app.listen(process.env.PORT, () => `Listening!✅`);\n```\n [ CodeSandBox](https://codesandbox.io/s/a03blueprint-forked-89y5yu?file=/src/server.js)\n\n## 장단점\n- 장점\n  - object들 간 수정을 하지 않고 관계를 수정할 수 있다.\n  - object들 간의 관계의 복잡도, 의존성 및 결합도를 감소시킨다.\n다대 다의 복잡한 의존 관계를 풀어나감\n- 단점\n  - 중재자에 권한이 집중되어 있으므로 잘못된 중재자의 설계는 더 복잡한 객체를 생성할 수 있다. \n\n## 참고\n\n[Mediator/Middleware Pattern](https://www.patterns.dev/posts/mediator-pattern/)\n\n- JavaScript patterns - Stoyan Stefaonv\n- Node.js 디자인 패턴 바이블 - Mario Casciaro, Luciano Mammino\n",
          "commentCounts": 0
        }
      ]
    }
  ],
  "task": {
    "todo": [],
    "doing": [],
    "review": [],
    "done": []
  },
  "result": [
    {
      "id": 0,
      "categoryIndex": 0,
      "part": "plan",
      "topic": "배경/문제인식",
      "contents": "> *Use a central mediator object to handle communication between components*\n\n## Mediator\n\n- 애플리케이션은 독립된 object들로 만들어진다. \nobject간의 통신은 유지보수가 쉽고 다른 object를 건드리지 않으면서, 애플리케이션의 일부분을 안전하게 수정할 수 있는 방식으로 이루어져야한다.\n    ![](https://velog.velcdn.com/images/sang-mini/post/4d7e63eb-a41d-4211-8238-ddd0c042170c/image.png)\n\n\n    \n\n- 애플리케이션의 크기가 커져가면서 더욱 더 많은 object들이 추가, 제거, 재배치된다. 이때 object들이 서로에 대해 너무 많은 정보를 아는 상태로 직접 통신하게 되면 서로간의 결합도가 높아져 바람직하지 않다. **object들이 강하게 결합되면, 다른 object들에 영향을 주지 않고 하나의 object를 수정하기가 어렵다.** \n\n- 우리는 object 간의 다방향 데이터를 처리해야 한다. 하지만 component가 많으면 component 간의 통신이 다소 혼란스러울 수 있다.\n- 이러한 이유로 component들이 서로 직접 통신하는 대신 mediator를 통하도록 한다. \n(mediator가 관제탑, component가 비행기라고 생각하면 된다.)\n\n\n>  _ component vs object\n 컴포넌트가 사람이 눈으로 확인할 수 있는 결과물이라면 객체는 사람이 눈으로 확인할 수 없는 작은 단위의 사물과 같다. 객체도 독립적으로 작동할 수 있지만 보통 다른 객체와 관계를 맺어 결과물을 제출한다. 다른 객체와 관계를 맺어 하나의 모듈이 되었으면 이 모듈이 곧 컴포넌트가 되기도 한다. 객체는 컴포넌트보다는 작은 단위의 기능을 수행한다. 컴포넌트는 독립적으로 작동하는 큰 단위의 모듈이다. 객체가 모여 컴포넌트가 된다. 컴포넌트는 사람이 직접적, 물질적으로 인식할 수 있는 대상이다._\n\n\n\n\n- **Mediator pattern**에서는 독립된 object들은 다른 object와 직접 통신하지 않고, **Mediator**를 거친다. \nJS에서 Mediator는 보통 object literal이나 function으로 구현된다. \n![](https://velog.velcdn.com/images/sang-mini/post/cfcaeff3-4401-4f25-adfc-6bdfdb44a4be/image.png)\n\n - ### 활용 \n 채팅방 기능\n```javascript\nclass ChatRoom {\n  logMessage(user, message) {\n    const time = new Date();\n    const sender = user.getName();\n\n    console.log(`${time} [${sender}]: ${message}`);\n  }\n}\n\n class User {\n  constructor(name, chatroom) {\n    this.name = name;\n    this.chatroom = chatroom;\n  }\n\n  getName() {\n    return this.name;\n  }\n\n  send(message) {\n    this.chatroom.logMessage(this, message);\n  }\n}\n```\n\n  [CodeSandBox](https://codesandbox.io/s/middleware-1-forked-jxts4w?file=/src/index.js)\n\n## Middleware\n\n- **Middleware** = middle software\nmiddleware는 **request와 respond 사이**에 있는 contoller다.\n- express가 middleware라는 용어를 대중화하여 구체적으로 디자인 패턴을 구현했다. 이를 통해 개발자가 프레임워크의 핵심에 손대지 않고도 새로운 기능을 쉽게 만들고 배포하여 기능을 추가할 수 있도록 했다.\n- 구조\n![](https://velog.velcdn.com/images/sang-mini/post/e0a0ce03-d617-4f04-8602-5110aff64d88/image.png)\n\n - middleware에 처리를 위한 새로운 데이터가 수신되면 등록된 middleware 들이 비동기 순차 실행 흐름으로 호출된다. next 함수가 req - res 사이클에 걸려있는 다음 callback을 호출한다.\n-각 middleware는 데이터의 추가적인 처리를 중단시킬 수 있다. callback을 호출하지 않거나 오류를 전파하여 동작한다. \n\n- 새로운 middleware는 use()함수를 통해 등록할 수 있다. \n```jsx\n    const app = require('express')()\n    \n    app.use('/', (req, res, next) => {\n      req.headers['test-header'] = 1234\n      next()\n    })\n```\n\n\n### 활용\n이 미들웨어 패턴은 여러 객체 간 다대 다의 통신을 하나의 관리 포인트를 통하도록 만들어 관계를 단순하게 만들어준다.\n```jsx\n    import express from \"express\";\n    \n    const app = express();\n    \n    const urlLogger = (req, res, next) => {\n      console.log(`Path: ${req.path}`);\n      next();\n    };\n    \n    const timeLogger = (req, res, next) => {\n      const today = new Date();\n      const year = today.getFullYear();\n      const month = today.getMonth() + 1;\n      const day = today.getDate();\n      const date = `${year}.${month}.${day}`;\n      console.log(`Time: ${date}`);\n      next();\n    };\n    \n    const securityLogger = (req, res, next) => {\n      req.protocol === \"https\" ? console.log(\"Secure\") : console.log(\"Insecure\");\n      next();\n    };\n    \n    const protector = (req, res) => {\n      res.end();\n    };\n    \n    app.use(urlLogger, timeLogger, securityLogger);\n    app.get(\"/\", (req, res) => res.send(\"<h1>Home</h1>\"));\n    app.get(\"/protected\", protector, (req, res) => res.send(\"<h1>Protected</h1>\"));\n    \n    app.listen(process.env.PORT, () => `Listening!✅`);\n```\n [ CodeSandBox](https://codesandbox.io/s/a03blueprint-forked-89y5yu?file=/src/server.js)\n\n## 장단점\n- 장점\n  - object들 간 수정을 하지 않고 관계를 수정할 수 있다.\n  - object들 간의 관계의 복잡도, 의존성 및 결합도를 감소시킨다.\n다대 다의 복잡한 의존 관계를 풀어나감\n- 단점\n  - 중재자에 권한이 집중되어 있으므로 잘못된 중재자의 설계는 더 복잡한 객체를 생성할 수 있다. \n\n## 참고\n\n[Mediator/Middleware Pattern](https://www.patterns.dev/posts/mediator-pattern/)\n\n- JavaScript patterns - Stoyan Stefaonv\n- Node.js 디자인 패턴 바이블 - Mario Casciaro, Luciano Mammino\n",
      "commentCounts": 0
    },
    {
      "id": 1,
      "categoryIndex": 1,
      "part": "plan",
      "topic": "타겟설정",
      "contents": "## 도입\n\n\n**React Query**는 통신, 캐싱, 에러처리 등에서의 많은 장점을 가지고 있다. 나는 데이터 통신 위주로 가볍게 사용해보고 정리하려 한다. loading을 useState로 만들고, useEffect로 데이터를 받아온 후 state를 바꿔주는 과정을 간단하게 대체하고 재활용 가능한 코드로 만들어준다는 것만으로도 매력적이었다. \n\n## Setting\n\n```jsx\nnpm i @tanstack/react-query\n```\n\n1. queryClient 만들기\n    \n    ```tsx\n    //index.tsx\n    import { QueryClient, QueryClientProvider } from \"@tanstack/react-query\";\n    \n    const queryClient = new QueryClient();\n    ```\n    \n2. application을 QueryClientProvider로 감싸기\n    \n    ```tsx\n    //index.tsx\n    <QueryClientProvider client={queryClient}>   \n    \t\t<App />    \n    </QueryClientProvider>\n    ```\n    \n3. fetcher 만들기\nreact query는 fetcher함수를 만들 수 있게 해준다.  기본적으로 fetcher function과 연결시켜서 isLoading 같은 함수가 불렸는지 아닌지를 알려준다. 함수가 끝났을 때는 결과 값을 data에 주고 그 data에 아주 쉬운 방법으로 접근할 수 있게 도와준다. \n    \n   ```tsx\n    \t//api.ts\n    export function getTasks() {\n    return fetch(`${BASE_URL}/task`).then((response) => response.json());\n\t\t}\n   ```\n   _다른 컴포넌트에서 import해서 사용할 수 있도록 export 해준다._\n\n## 사용하기\n- useQuery는 isLoading, data, error, isError등 많은 것에 접근할 수 있다. key와 fetcher 함수를 넣어주면 바로 사용할 수 있다. 이때 key는 array로 줄 것. (version 4 로 오면서 바뀜)\n    \n    ```jsx\n    const { isLoading, data } = useQuery([\"tasks\"], getTasks);\n    ```\n    \n    이때, 필요하다면(typescript) data의 타입을 알려준다.\n    \n    ```tsx\n\tinterface IContents {\n  \t\tid: number;\n  \t\tcategoryIndex: number;\n        \tpart: string;\n  \t\ttopic: string;\n  \t\tcontents: any;\n  \t\tcommentCounts: number;\n\t\t}\n\n     \t\t const { isLoading: contentLoading, data: contentData } = useQuery<IContents>(\n    \t\t\t[\"content\", contentId],\n   \t \t\t() => getContents(contentId)\n  \t\t);\n    ```\nreact query는 아주 강력한 캐싱 매커니즘을 가지고 있다. 만약 query의 고유한 key값을 react query에 넘겨 주었다면 react query는 캐시에 이미 data가 있는 것을 알고 loading을 보여주지 않고 페이지를 넘겨준다. \n    또, 같은 쿼리를 다른 화면이나 다른 컴포넌트에서 사용했다면 fetch가 다시 일어나지 않을 것이다.\n    \n\n - argument를 필요로 하는 fetcher function의 경우에는 익명의 함수를 만들어서 fetcher function를 return해준다.\n  ```tsx\ngetTasks\n() => getTasks()\n//두 표현이 동일한 의미이다. \n  ```\n  _ getTasks(id)로 적을경우 함수가 바로 실행되기 때문에 적절하지 못하다. _\n  \n\n ",
      "commentCounts": 1
    },
    {
      "id": 2,
      "categoryIndex": 2,
      "part": "plan",
      "topic": "시장조사/자료조사",
      "contents": "",
      "commentCounts": 1
    },
    {
      "id": 3,
      "categoryIndex": 3,
      "part": "plan",
      "topic": "솔루션",
      "contents": "이게 왜 바로 안넘어 갈까?\n**이걸 어떻게 비동기 처리하지.........**\n이제 또 넘어가기 시작하네",
      "commentCounts": 0
    },
    {
      "id": 4,
      "categoryIndex": 4,
      "part": "plan",
      "topic": "목표가 아닌 것",
      "contents": "처음 올릴때만 안되는 건가?\n이제 될듯",
      "commentCounts": 4
    },
    {
      "id": 5,
      "categoryIndex": 5,
      "part": "plan",
      "topic": "벤치마크",
      "contents": "",
      "commentCounts": 1
    },
    {
      "id": 6,
      "categoryIndex": 0,
      "part": "design",
      "topic": "Mood board",
      "contents": "",
      "commentCounts": 1
    },
    {
      "id": 7,
      "categoryIndex": 1,
      "part": "design",
      "topic": "Key color/visual",
      "contents": "# 테스트 중임\n\n\n<br>\n",
      "commentCounts": 1
    },
    {
      "id": 8,
      "categoryIndex": 2,
      "part": "design",
      "topic": "UI sketch",
      "contents": "",
      "commentCounts": 1
    },
    {
      "id": 9,
      "categoryIndex": 3,
      "part": "design",
      "topic": "Wireframe",
      "contents": "",
      "commentCounts": 1
    },
    {
      "id": 10,
      "categoryIndex": 1,
      "part": "frontend",
      "topic": "Setting",
      "contents": "",
      "commentCounts": 1
    },
    {
      "id": 11,
      "categoryIndex": 2,
      "part": "frontend",
      "topic": "Home",
      "contents": "",
      "commentCounts": 1
    },
    {
      "id": 12,
      "categoryIndex": 3,
      "part": "frontend",
      "topic": "Other page",
      "contents": "",
      "commentCounts": 1
    },
    {
      "id": 13,
      "categoryIndex": 4,
      "part": "frontend",
      "topic": "Join",
      "contents": "",
      "commentCounts": 1
    },
    {
      "id": 14,
      "categoryIndex": 5,
      "part": "frontend",
      "topic": "Profile",
      "contents": "",
      "commentCounts": 1
    },
    {
      "id": 15,
      "categoryIndex": 6,
      "part": "frontend",
      "topic": "Board",
      "contents": "",
      "commentCounts": 1
    },
    {
      "id": 16,
      "categoryIndex": 0,
      "part": "backend",
      "topic": "초기설정",
      "contents": "",
      "commentCounts": 1
    },
    {
      "id": 17,
      "categoryIndex": 1,
      "part": "backend",
      "topic": "Router setting",
      "contents": "",
      "commentCounts": 1
    },
    {
      "id": 18,
      "categoryIndex": 2,
      "part": "backend",
      "topic": "DB구상",
      "contents": "",
      "commentCounts": 1
    },
    {
      "id": 19,
      "categoryIndex": 3,
      "part": "backend",
      "topic": "DB구현",
      "contents": "",
      "commentCounts": 1
    },
    {
      "id": 20,
      "categoryIndex": 4,
      "part": "backend",
      "topic": "상세기능 구현",
      "contents": "",
      "commentCounts": 1
    },
    {
      "id": 21,
      "categoryIndex": 5,
      "part": "backend",
      "topic": "배포환경설정",
      "contents": "",
      "commentCounts": 1
    }
  ],
  "backup": {
    "plan": [
      {
        "id": 0,
        "categoryIndex": 0,
        "part": "plan",
        "topic": "배경/문제인식",
        "contents": "",
        "commentCounts": 0
      },
      {
        "id": 1,
        "categoryIndex": 1,
        "part": "plan",
        "topic": "타겟설정",
        "contents": "",
        "commentCounts": 1
      },
      {
        "id": 2,
        "categoryIndex": 2,
        "part": "plan",
        "topic": "시장조사/자료조사",
        "contents": "",
        "commentCounts": 1
      },
      {
        "id": 3,
        "categoryIndex": 3,
        "part": "plan",
        "topic": "솔루션",
        "contents": "이게 왜 바로 안넘어 갈까?\n**이걸 어떻게 비동기 처리하지.........**\n이제 또 넘어가기 시작하네",
        "commentCounts": 0
      },
      {
        "id": 4,
        "categoryIndex": 4,
        "part": "plan",
        "topic": "목표가 아닌 것",
        "contents": "처음 올릴때만 안되는 건가?\n이제 될듯",
        "commentCounts": 4
      },
      {
        "id": 5,
        "categoryIndex": 5,
        "part": "plan",
        "topic": "벤치마크",
        "contents": "",
        "commentCounts": 1
      }
    ],
    "design": [
      {
        "id": 6,
        "categoryIndex": 0,
        "part": "design",
        "topic": "Mood board",
        "contents": "",
        "commentCounts": 1
      },
      {
        "id": 7,
        "categoryIndex": 1,
        "part": "design",
        "topic": "Key color/visual",
        "contents": "",
        "commentCounts": 1
      },
      {
        "id": 8,
        "categoryIndex": 2,
        "part": "design",
        "topic": "UI sketch",
        "contents": "",
        "commentCounts": 1
      },
      {
        "id": 9,
        "categoryIndex": 3,
        "part": "design",
        "topic": "Wireframe",
        "contents": "",
        "commentCounts": 1
      }
    ],
    "frontend": [
      {
        "id": 10,
        "categoryIndex": 1,
        "part": "frontend",
        "topic": "Setting",
        "contents": "",
        "commentCounts": 1
      },
      {
        "id": 11,
        "categoryIndex": 2,
        "part": "frontend",
        "topic": "Home",
        "contents": "",
        "commentCounts": 1
      },
      {
        "id": 12,
        "categoryIndex": 3,
        "part": "frontend",
        "topic": "Other page",
        "contents": "",
        "commentCounts": 1
      },
      {
        "id": 13,
        "categoryIndex": 4,
        "part": "frontend",
        "topic": "Join",
        "contents": "",
        "commentCounts": 1
      },
      {
        "id": 14,
        "categoryIndex": 5,
        "part": "frontend",
        "topic": "Profile",
        "contents": "",
        "commentCounts": 1
      },
      {
        "id": 15,
        "categoryIndex": 6,
        "part": "frontend",
        "topic": "Board",
        "contents": "",
        "commentCounts": 1
      }
    ],
    "backend": [
      {
        "id": 16,
        "categoryIndex": 0,
        "part": "backend",
        "topic": "초기설정",
        "contents": "",
        "commentCounts": 1
      },
      {
        "id": 17,
        "categoryIndex": 1,
        "part": "backend",
        "topic": "Router setting",
        "contents": "",
        "commentCounts": 1
      },
      {
        "id": 18,
        "categoryIndex": 2,
        "part": "backend",
        "topic": "DB구상",
        "contents": "",
        "commentCounts": 1
      },
      {
        "id": 19,
        "categoryIndex": 3,
        "part": "backend",
        "topic": "DB구현",
        "contents": "",
        "commentCounts": 1
      },
      {
        "id": 20,
        "categoryIndex": 4,
        "part": "backend",
        "topic": "상세기능 구현",
        "contents": "",
        "commentCounts": 1
      },
      {
        "id": 21,
        "categoryIndex": 5,
        "part": "backend",
        "topic": "배포환경설정",
        "contents": "",
        "commentCounts": 1
      }
    ]
  },
  "user": [
    {
      "id": 0,
      "username": "김상민",
      "userId": "mini",
      "password": "21kdh2i3@#",
      "userAge": "25",
      "userBelong": "숭실대학교",
      "userPart": "Frontend",
      "quotes": "하늘이 내려준 천재"
    }
  ],
  "project": [
    {
      "id": 0,
      "title": "수나롭다",
      "teammates": ["김상민", "안영훈", "이예린", "이진형"],
      "duration": ["9월20일", "12월20일"],
      "introduction": "개발자와 비개발자의 협업을 위한 새로운 협업 플랫폼..!"
    },
    {
      "id": 1,
      "title": "수나롭다",
      "teammates": ["김상민", "안영훈", "이예린", "이진형"],
      "duration": ["9월20일", "12월20일"],
      "introduction": "개발자와 비개발자의 협업을 위한 새로운 협업 플랫폼..!"
    },
    {
      "id": 2,
      "title": "수나롭다",
      "teammates": ["김상민", "안영훈", "이예린", "이진형"],
      "duration": ["9월20일", "12월20일"],
      "introduction": "개발자와 비개발자의 협업을 위한 새로운 협업 플랫폼..!"
    },
    {
      "id": 3,
      "title": "수나롭다",
      "teammates": ["김상민", "안영훈", "이예린", "이진형"],
      "duration": ["9월20일", "12월20일"],
      "introduction": "개발자와 비개발자의 협업을 위한 새로운 협업 플랫폼..!"
    }
  ],
  "join": {
    "email": "min@naver.com",
    "password": "1001",
    "name": "김상민"
  },
  "mini@naver.com": {
    "project_list": [
      {
        "id": 0,
        "title": "수나롭다",
        "teammates": ["email", "email"],
        "teammates_name": ["김상민", "안영훈", "이예린", "이진형"],
        "duration": "2022년 12월 8일 목요일 ~ 2022년 12월 31일 토요일",
        "introduction": "개발자와 비개발자의 협업을 위한 새로운 협업 플랫폼..!"
      },
      {
        "id": 1,
        "title": "수나롭다",
        "teammates": ["email", "email"],
        "teammates_name": ["김상민", "안영훈", "이예린", "이진형"],
        "duration": "2022년 12월 8일 목요일 ~ 2022년 12월 31일 토요일",
        "introduction": "개발자와 비개발자의 협업을 위한 새로운 협업 플랫폼..!"
      },
      {
        "id": 2,
        "title": "수나롭다",
        "teammates": ["email", "email"],
        "teammates_name": ["김상민", "안영훈", "이예린", "이진형"],
        "duration": "2022년 12월 8일 목요일 ~ 2022년 12월 31일 토요일",
        "introduction": "개발자와 비개발자의 협업을 위한 새로운 협업 플랫폼..!"
      },
      {
        "id": 3,
        "title": "수나롭다",
        "teammates": ["email", "email"],
        "teammates_name": ["김상민", "안영훈", "이예린", "이진형"],
        "duration": "2022년 12월 8일 목요일 ~ 2022년 12월 31일 토요일",
        "introduction": "개발자와 비개발자의 협업을 위한 새로운 협업 플랫폼..!"
      }
    ],
    "user": {
      "name": "김상민",
      "information": "나이를 입력하세요, 파트를 입력하세요, 학교/회사 이름을 입력해주세요, 나를 표현하는 한줄"
    }
  }
}
